/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/extsprintf";
exports.ids = ["vendor-chunks/extsprintf"];
exports.modules = {

/***/ "(action-browser)/./node_modules/extsprintf/lib/extsprintf.js":
/*!***************************************************!*\
  !*** ./node_modules/extsprintf/lib/extsprintf.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * extsprintf.js: extended POSIX-style sprintf\n */ var mod_assert = __webpack_require__(/*! assert */ \"assert\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\n/*\n * Public interface\n */ exports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */ function jsSprintf(fmt) {\n    var regex = [\n        \"([^%]*)\",\n        /* normal text */ \"%\",\n        /* start of format */ \"(['\\\\-+ #0]*?)\",\n        /* flags (optional) */ \"([1-9]\\\\d*)?\",\n        /* width (optional) */ \"(\\\\.([1-9]\\\\d*))?\",\n        /* precision (optional) */ \"[lhjztL]*?\",\n        /* length mods (ignored) */ \"([diouxXfFeEgGaAcCsSp%jr])\" /* conversion */ \n    ].join(\"\");\n    var re = new RegExp(regex);\n    var args = Array.prototype.slice.call(arguments, 1);\n    var flags, width, precision, conversion;\n    var left, pad, sign, arg, match;\n    var ret = \"\";\n    var argn = 1;\n    mod_assert.equal(\"string\", typeof fmt);\n    while((match = re.exec(fmt)) !== null){\n        ret += match[1];\n        fmt = fmt.substring(match[0].length);\n        flags = match[2] || \"\";\n        width = match[3] || 0;\n        precision = match[4] || \"\";\n        conversion = match[6];\n        left = false;\n        sign = false;\n        pad = \" \";\n        if (conversion == \"%\") {\n            ret += \"%\";\n            continue;\n        }\n        if (args.length === 0) throw new Error(\"too few args to sprintf\");\n        arg = args.shift();\n        argn++;\n        if (flags.match(/[\\' #]/)) throw new Error(\"unsupported flags: \" + flags);\n        if (precision.length > 0) throw new Error(\"non-zero precision not supported\");\n        if (flags.match(/-/)) left = true;\n        if (flags.match(/0/)) pad = \"0\";\n        if (flags.match(/\\+/)) sign = true;\n        switch(conversion){\n            case \"s\":\n                if (arg === undefined || arg === null) throw new Error(\"argument \" + argn + \": attempted to print undefined or null \" + \"as a string\");\n                ret += doPad(pad, width, left, arg.toString());\n                break;\n            case \"d\":\n                arg = Math.floor(arg);\n            /*jsl:fallthru*/ case \"f\":\n                sign = sign && arg > 0 ? \"+\" : \"\";\n                ret += sign + doPad(pad, width, left, arg.toString());\n                break;\n            case \"x\":\n                ret += doPad(pad, width, left, arg.toString(16));\n                break;\n            case \"j\":\n                /* non-standard */ if (width === 0) width = 10;\n                ret += mod_util.inspect(arg, false, width);\n                break;\n            case \"r\":\n                /* non-standard */ ret += dumpException(arg);\n                break;\n            default:\n                throw new Error(\"unsupported conversion: \" + conversion);\n        }\n    }\n    ret += fmt;\n    return ret;\n}\nfunction jsPrintf() {\n    var args = Array.prototype.slice.call(arguments);\n    args.unshift(process.stdout);\n    jsFprintf.apply(null, args);\n}\nfunction jsFprintf(stream) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return stream.write(jsSprintf.apply(this, args));\n}\nfunction doPad(chr, width, left, str) {\n    var ret = str;\n    while(ret.length < width){\n        if (left) ret += chr;\n        else ret = chr + ret;\n    }\n    return ret;\n}\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */ function dumpException(ex) {\n    var ret;\n    if (!(ex instanceof Error)) throw new Error(jsSprintf(\"invalid type for %%r: %j\", ex));\n    /* Note that V8 prepends \"ex.stack\" with ex.toString(). */ ret = \"EXCEPTION: \" + ex.constructor.name + \": \" + ex.stack;\n    if (ex.cause && typeof ex.cause === \"function\") {\n        var cex = ex.cause();\n        if (cex) {\n            ret += \"\\nCaused by: \" + dumpException(cex);\n        }\n    }\n    return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9leHRzcHJpbnRmL2xpYi9leHRzcHJpbnRmLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQsSUFBSUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDekIsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUM7QUFFdkI7O0NBRUMsR0FDREUsZUFBZSxHQUFHRTtBQUNsQkYsY0FBYyxHQUFHSTtBQUNqQkosZUFBZSxHQUFHTTtBQUVsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxTQUFTSixVQUFVSyxHQUFHO0lBRXJCLElBQUlDLFFBQVE7UUFDUjtRQUFjLGVBQWUsR0FDN0I7UUFBUSxtQkFBbUIsR0FDM0I7UUFBcUIsb0JBQW9CLEdBQ3pDO1FBQWtCLG9CQUFvQixHQUN0QztRQUFzQix3QkFBd0IsR0FDOUM7UUFBZ0IseUJBQXlCLEdBQ3pDLDZCQUE2QixjQUFjO0tBQzlDLENBQUNDLElBQUksQ0FBQztJQUVQLElBQUlDLEtBQUssSUFBSUMsT0FBT0g7SUFDcEIsSUFBSUksT0FBT0MsTUFBTUMsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ0MsV0FBVztJQUNqRCxJQUFJQyxPQUFPQyxPQUFPQyxXQUFXQztJQUM3QixJQUFJQyxNQUFNQyxLQUFLQyxNQUFNQyxLQUFLQztJQUMxQixJQUFJQyxNQUFNO0lBQ1YsSUFBSUMsT0FBTztJQUVYL0IsV0FBV2dDLEtBQUssQ0FBQyxVQUFVLE9BQVF0QjtJQUVuQyxNQUFPLENBQUNtQixRQUFRaEIsR0FBR29CLElBQUksQ0FBQ3ZCLElBQUcsTUFBTyxLQUFNO1FBQ3ZDb0IsT0FBT0QsS0FBSyxDQUFDLEVBQUU7UUFDZm5CLE1BQU1BLElBQUl3QixTQUFTLENBQUNMLEtBQUssQ0FBQyxFQUFFLENBQUNNLE1BQU07UUFFbkNkLFFBQVFRLEtBQUssQ0FBQyxFQUFFLElBQUk7UUFDcEJQLFFBQVFPLEtBQUssQ0FBQyxFQUFFLElBQUk7UUFDcEJOLFlBQVlNLEtBQUss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LE9BQU8sa0JBQWtCYyxjQUFjYztRQUN4QztJQUNEO0lBRUEsT0FBUTVCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbm5vdmF0aW9uLWNvYWNoLy4vbm9kZV9tb2R1bGVzL2V4dHNwcmludGYvbGliL2V4dHNwcmludGYuanM/ODM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogZXh0c3ByaW50Zi5qczogZXh0ZW5kZWQgUE9TSVgtc3R5bGUgc3ByaW50ZlxuICovXG5cbnZhciBtb2RfYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgbW9kX3V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qXG4gKiBQdWJsaWMgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydHMuc3ByaW50ZiA9IGpzU3ByaW50ZjtcbmV4cG9ydHMucHJpbnRmID0ganNQcmludGY7XG5leHBvcnRzLmZwcmludGYgPSBqc0ZwcmludGY7XG5cbi8qXG4gKiBTdHJpcHBlZCBkb3duIHZlcnNpb24gb2Ygc1tuXXByaW50ZigzYykuICBXZSBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdGhyb3cgYW5cbiAqIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGEgZm9ybWF0IHN0cmluZyB3ZSBkb24ndCB1bmRlcnN0YW5kLCByYXRoZXIgdGhhblxuICogaWdub3JpbmcgaXQsIHNvIHRoYXQgd2Ugd29uJ3QgYnJlYWsgZXhpc3RpbmcgcHJvZ3JhbXMgaWYvd2hlbiB3ZSBnbyBpbXBsZW1lbnRcbiAqIHRoZSByZXN0IG9mIHRoaXMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgc3VwcG9ydHMgc3BlY2lmeWluZ1xuICpcdC0gZmllbGQgYWxpZ25tZW50ICgnLScgZmxhZyksXG4gKiBcdC0gemVyby1wYWQgKCcwJyBmbGFnKVxuICpcdC0gYWx3YXlzIHNob3cgbnVtZXJpYyBzaWduICgnKycgZmxhZyksXG4gKlx0LSBmaWVsZCB3aWR0aFxuICpcdC0gY29udmVyc2lvbnMgZm9yIHN0cmluZ3MsIGRlY2ltYWwgaW50ZWdlcnMsIGFuZCBmbG9hdHMgKG51bWJlcnMpLlxuICpcdC0gYXJndW1lbnQgc2l6ZSBzcGVjaWZpZXJzLiAgVGhlc2UgYXJlIGFsbCBhY2NlcHRlZCBidXQgaWdub3JlZCwgc2luY2VcbiAqXHQgIEphdmFzY3JpcHQgaGFzIG5vIG5vdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2l6ZSBvZiBhbiBhcmd1bWVudC5cbiAqXG4gKiBFdmVyeXRoaW5nIGVsc2UgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLCBtb3N0IG5vdGFibHkgcHJlY2lzaW9uLCB1bnNpZ25lZFxuICogbnVtYmVycywgbm9uLWRlY2ltYWwgbnVtYmVycywgYW5kIGNoYXJhY3RlcnMuXG4gKi9cbmZ1bmN0aW9uIGpzU3ByaW50ZihmbXQpXG57XG5cdHZhciByZWdleCA9IFtcblx0ICAgICcoW14lXSopJyxcdFx0XHRcdC8qIG5vcm1hbCB0ZXh0ICovXG5cdCAgICAnJScsXHRcdFx0XHQvKiBzdGFydCBvZiBmb3JtYXQgKi9cblx0ICAgICcoW1xcJ1xcXFwtKyAjMF0qPyknLFx0XHRcdC8qIGZsYWdzIChvcHRpb25hbCkgKi9cblx0ICAgICcoWzEtOV1cXFxcZCopPycsXHRcdFx0Lyogd2lkdGggKG9wdGlvbmFsKSAqL1xuXHQgICAgJyhcXFxcLihbMS05XVxcXFxkKikpPycsXHRcdC8qIHByZWNpc2lvbiAob3B0aW9uYWwpICovXG5cdCAgICAnW2xoanp0TF0qPycsXHRcdFx0LyogbGVuZ3RoIG1vZHMgKGlnbm9yZWQpICovXG5cdCAgICAnKFtkaW91eFhmRmVFZ0dhQWNDc1NwJWpyXSknXHQvKiBjb252ZXJzaW9uICovXG5cdF0uam9pbignJyk7XG5cblx0dmFyIHJlID0gbmV3IFJlZ0V4cChyZWdleCk7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0dmFyIGZsYWdzLCB3aWR0aCwgcHJlY2lzaW9uLCBjb252ZXJzaW9uO1xuXHR2YXIgbGVmdCwgcGFkLCBzaWduLCBhcmcsIG1hdGNoO1xuXHR2YXIgcmV0ID0gJyc7XG5cdHZhciBhcmduID0gMTtcblxuXHRtb2RfYXNzZXJ0LmVxdWFsKCdzdHJpbmcnLCB0eXBlb2YgKGZtdCkpO1xuXG5cdHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZtdCkpICE9PSBudWxsKSB7XG5cdFx0cmV0ICs9IG1hdGNoWzFdO1xuXHRcdGZtdCA9IGZtdC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcblxuXHRcdGZsYWdzID0gbWF0Y2hbMl0gfHwgJyc7XG5cdFx0d2lkdGggPSBtYXRjaFszXSB8fCAwO1xuXHRcdHByZWNpc2lvbiA9IG1hdGNoWzRdIHx8ICcnO1xuXHRcdGNvbnZlcnNpb24gPSBtYXRjaFs2XTtcblx0XHRsZWZ0ID0gZmFsc2U7XG5cdFx0c2lnbiA9IGZhbHNlO1xuXHRcdHBhZCA9ICcgJztcblxuXHRcdGlmIChjb252ZXJzaW9uID09ICclJykge1xuXHRcdFx0cmV0ICs9ICclJztcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3RvbyBmZXcgYXJncyB0byBzcHJpbnRmJykpO1xuXG5cdFx0YXJnID0gYXJncy5zaGlmdCgpO1xuXHRcdGFyZ24rKztcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvW1xcJyAjXS8pKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcihcblx0XHRcdCAgICAndW5zdXBwb3J0ZWQgZmxhZ3M6ICcgKyBmbGFncykpO1xuXG5cdFx0aWYgKHByZWNpc2lvbi5sZW5ndGggPiAwKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcihcblx0XHRcdCAgICAnbm9uLXplcm8gcHJlY2lzaW9uIG5vdCBzdXBwb3J0ZWQnKSk7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goLy0vKSlcblx0XHRcdGxlZnQgPSB0cnVlO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC8wLykpXG5cdFx0XHRwYWQgPSAnMCc7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goL1xcKy8pKVxuXHRcdFx0c2lnbiA9IHRydWU7XG5cblx0XHRzd2l0Y2ggKGNvbnZlcnNpb24pIHtcblx0XHRjYXNlICdzJzpcblx0XHRcdGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwpXG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2FyZ3VtZW50ICcgKyBhcmduICtcblx0XHRcdFx0ICAgICc6IGF0dGVtcHRlZCB0byBwcmludCB1bmRlZmluZWQgb3IgbnVsbCAnICtcblx0XHRcdFx0ICAgICdhcyBhIHN0cmluZycpKTtcblx0XHRcdHJldCArPSBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LCBhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2QnOlxuXHRcdFx0YXJnID0gTWF0aC5mbG9vcihhcmcpO1xuXHRcdFx0Lypqc2w6ZmFsbHRocnUqL1xuXHRcdGNhc2UgJ2YnOlxuXHRcdFx0c2lnbiA9IHNpZ24gJiYgYXJnID4gMCA/ICcrJyA6ICcnO1xuXHRcdFx0cmV0ICs9IHNpZ24gKyBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LFxuXHRcdFx0ICAgIGFyZy50b1N0cmluZygpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAneCc6XG5cdFx0XHRyZXQgKz0gZG9QYWQocGFkLCB3aWR0aCwgbGVmdCwgYXJnLnRvU3RyaW5nKDE2KSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2onOiAvKiBub24tc3RhbmRhcmQgKi9cblx0XHRcdGlmICh3aWR0aCA9PT0gMClcblx0XHRcdFx0d2lkdGggPSAxMDtcblx0XHRcdHJldCArPSBtb2RfdXRpbC5pbnNwZWN0KGFyZywgZmFsc2UsIHdpZHRoKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAncic6IC8qIG5vbi1zdGFuZGFyZCAqL1xuXHRcdFx0cmV0ICs9IGR1bXBFeGNlcHRpb24oYXJnKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGNvbnZlcnNpb246ICcgK1xuXHRcdFx0ICAgIGNvbnZlcnNpb24pKTtcblx0XHR9XG5cdH1cblxuXHRyZXQgKz0gZm10O1xuXHRyZXR1cm4gKHJldCk7XG59XG5cbmZ1bmN0aW9uIGpzUHJpbnRmKCkge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdGFyZ3MudW5zaGlmdChwcm9jZXNzLnN0ZG91dCk7XG5cdGpzRnByaW50Zi5hcHBseShudWxsLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24ganNGcHJpbnRmKHN0cmVhbSkge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdHJldHVybiAoc3RyZWFtLndyaXRlKGpzU3ByaW50Zi5hcHBseSh0aGlzLCBhcmdzKSkpO1xufVxuXG5mdW5jdGlvbiBkb1BhZChjaHIsIHdpZHRoLCBsZWZ0LCBzdHIpXG57XG5cdHZhciByZXQgPSBzdHI7XG5cblx0d2hpbGUgKHJldC5sZW5ndGggPCB3aWR0aCkge1xuXHRcdGlmIChsZWZ0KVxuXHRcdFx0cmV0ICs9IGNocjtcblx0XHRlbHNlXG5cdFx0XHRyZXQgPSBjaHIgKyByZXQ7XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGR1bXBzIGxvbmcgc3RhY2sgdHJhY2VzIGZvciBleGNlcHRpb25zIGhhdmluZyBhIGNhdXNlKCkgbWV0aG9kLlxuICogU2VlIG5vZGUtdmVycm9yIGZvciBhbiBleGFtcGxlLlxuICovXG5mdW5jdGlvbiBkdW1wRXhjZXB0aW9uKGV4KVxue1xuXHR2YXIgcmV0O1xuXG5cdGlmICghKGV4IGluc3RhbmNlb2YgRXJyb3IpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoanNTcHJpbnRmKCdpbnZhbGlkIHR5cGUgZm9yICUlcjogJWonLCBleCkpKTtcblxuXHQvKiBOb3RlIHRoYXQgVjggcHJlcGVuZHMgXCJleC5zdGFja1wiIHdpdGggZXgudG9TdHJpbmcoKS4gKi9cblx0cmV0ID0gJ0VYQ0VQVElPTjogJyArIGV4LmNvbnN0cnVjdG9yLm5hbWUgKyAnOiAnICsgZXguc3RhY2s7XG5cblx0aWYgKGV4LmNhdXNlICYmIHR5cGVvZiAoZXguY2F1c2UpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGNleCA9IGV4LmNhdXNlKCk7XG5cdFx0aWYgKGNleCkge1xuXHRcdFx0cmV0ICs9ICdcXG5DYXVzZWQgYnk6ICcgKyBkdW1wRXhjZXB0aW9uKGNleCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChyZXQpO1xufVxuIl0sIm5hbWVzIjpbIm1vZF9hc3NlcnQiLCJyZXF1aXJlIiwibW9kX3V0aWwiLCJleHBvcnRzIiwic3ByaW50ZiIsImpzU3ByaW50ZiIsInByaW50ZiIsImpzUHJpbnRmIiwiZnByaW50ZiIsImpzRnByaW50ZiIsImZtdCIsInJlZ2V4Iiwiam9pbiIsInJlIiwiUmVnRXhwIiwiYXJncyIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiYXJndW1lbnRzIiwiZmxhZ3MiLCJ3aWR0aCIsInByZWNpc2lvbiIsImNvbnZlcnNpb24iLCJsZWZ0IiwicGFkIiwic2lnbiIsImFyZyIsIm1hdGNoIiwicmV0IiwiYXJnbiIsImVxdWFsIiwiZXhlYyIsInN1YnN0cmluZyIsImxlbmd0aCIsIkVycm9yIiwic2hpZnQiLCJ1bmRlZmluZWQiLCJkb1BhZCIsInRvU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaW5zcGVjdCIsImR1bXBFeGNlcHRpb24iLCJ1bnNoaWZ0IiwicHJvY2VzcyIsInN0ZG91dCIsImFwcGx5Iiwic3RyZWFtIiwid3JpdGUiLCJjaHIiLCJzdHIiLCJleCIsImNvbnN0cnVjdG9yIiwibmFtZSIsInN0YWNrIiwiY2F1c2UiLCJjZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/extsprintf/lib/extsprintf.js\n");

/***/ })

};
;