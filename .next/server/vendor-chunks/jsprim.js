/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsprim";
exports.ids = ["vendor-chunks/jsprim"];
exports.modules = {

/***/ "(action-browser)/./node_modules/jsprim/lib/jsprim.js":
/*!*******************************************!*\
  !*** ./node_modules/jsprim/lib/jsprim.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * lib/jsprim.js: utilities for primitive JavaScript types\n */ var mod_assert = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\nvar mod_extsprintf = __webpack_require__(/*! extsprintf */ \"(action-browser)/./node_modules/extsprintf/lib/extsprintf.js\");\nvar mod_verror = __webpack_require__(/*! verror */ \"(action-browser)/./node_modules/verror/lib/verror.js\");\nvar mod_jsonschema = __webpack_require__(/*! json-schema */ \"(action-browser)/./node_modules/json-schema/lib/validate.js\");\n/*\n * Public interface\n */ exports.deepCopy = deepCopy;\nexports.deepEqual = deepEqual;\nexports.isEmpty = isEmpty;\nexports.hasKey = hasKey;\nexports.forEachKey = forEachKey;\nexports.pluck = pluck;\nexports.flattenObject = flattenObject;\nexports.flattenIter = flattenIter;\nexports.validateJsonObject = validateJsonObjectJS;\nexports.validateJsonObjectJS = validateJsonObjectJS;\nexports.randElt = randElt;\nexports.extraProperties = extraProperties;\nexports.mergeObjects = mergeObjects;\nexports.startsWith = startsWith;\nexports.endsWith = endsWith;\nexports.parseInteger = parseInteger;\nexports.iso8601 = iso8601;\nexports.rfc1123 = rfc1123;\nexports.parseDateTime = parseDateTime;\nexports.hrtimediff = hrtimeDiff;\nexports.hrtimeDiff = hrtimeDiff;\nexports.hrtimeAccum = hrtimeAccum;\nexports.hrtimeAdd = hrtimeAdd;\nexports.hrtimeNanosec = hrtimeNanosec;\nexports.hrtimeMicrosec = hrtimeMicrosec;\nexports.hrtimeMillisec = hrtimeMillisec;\n/*\n * Deep copy an acyclic *basic* Javascript object.  This only handles basic\n * scalars (strings, numbers, booleans) and arbitrarily deep arrays and objects\n * containing these.  This does *not* handle instances of other classes.\n */ function deepCopy(obj) {\n    var ret, key;\n    var marker = \"__deepCopy\";\n    if (obj && obj[marker]) throw new Error(\"attempted deep copy of cyclic object\");\n    if (obj && obj.constructor == Object) {\n        ret = {};\n        obj[marker] = true;\n        for(key in obj){\n            if (key == marker) continue;\n            ret[key] = deepCopy(obj[key]);\n        }\n        delete obj[marker];\n        return ret;\n    }\n    if (obj && obj.constructor == Array) {\n        ret = [];\n        obj[marker] = true;\n        for(key = 0; key < obj.length; key++)ret.push(deepCopy(obj[key]));\n        delete obj[marker];\n        return ret;\n    }\n    /*\n\t * It must be a primitive type -- just return it.\n\t */ return obj;\n}\nfunction deepEqual(obj1, obj2) {\n    if (typeof obj1 != typeof obj2) return false;\n    if (obj1 === null || obj2 === null || typeof obj1 != \"object\") return obj1 === obj2;\n    if (obj1.constructor != obj2.constructor) return false;\n    var k;\n    for(k in obj1){\n        if (!obj2.hasOwnProperty(k)) return false;\n        if (!deepEqual(obj1[k], obj2[k])) return false;\n    }\n    for(k in obj2){\n        if (!obj1.hasOwnProperty(k)) return false;\n    }\n    return true;\n}\nfunction isEmpty(obj) {\n    var key;\n    for(key in obj)return false;\n    return true;\n}\nfunction hasKey(obj, key) {\n    mod_assert.equal(typeof key, \"string\");\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction forEachKey(obj, callback) {\n    for(var key in obj){\n        if (hasKey(obj, key)) {\n            callback(key, obj[key]);\n        }\n    }\n}\nfunction pluck(obj, key) {\n    mod_assert.equal(typeof key, \"string\");\n    return pluckv(obj, key);\n}\nfunction pluckv(obj, key) {\n    if (obj === null || typeof obj !== \"object\") return undefined;\n    if (obj.hasOwnProperty(key)) return obj[key];\n    var i = key.indexOf(\".\");\n    if (i == -1) return undefined;\n    var key1 = key.substr(0, i);\n    if (!obj.hasOwnProperty(key1)) return undefined;\n    return pluckv(obj[key1], key.substr(i + 1));\n}\n/*\n * Invoke callback(row) for each entry in the array that would be returned by\n * flattenObject(data, depth).  This is just like flattenObject(data,\n * depth).forEach(callback), except that the intermediate array is never\n * created.\n */ function flattenIter(data, depth, callback) {\n    doFlattenIter(data, depth, [], callback);\n}\nfunction doFlattenIter(data, depth, accum, callback) {\n    var each;\n    var key;\n    if (depth === 0) {\n        each = accum.slice(0);\n        each.push(data);\n        callback(each);\n        return;\n    }\n    mod_assert.ok(data !== null);\n    mod_assert.equal(typeof data, \"object\");\n    mod_assert.equal(typeof depth, \"number\");\n    mod_assert.ok(depth >= 0);\n    for(key in data){\n        each = accum.slice(0);\n        each.push(key);\n        doFlattenIter(data[key], depth - 1, each, callback);\n    }\n}\nfunction flattenObject(data, depth) {\n    if (depth === 0) return [\n        data\n    ];\n    mod_assert.ok(data !== null);\n    mod_assert.equal(typeof data, \"object\");\n    mod_assert.equal(typeof depth, \"number\");\n    mod_assert.ok(depth >= 0);\n    var rv = [];\n    var key;\n    for(key in data){\n        flattenObject(data[key], depth - 1).forEach(function(p) {\n            rv.push([\n                key\n            ].concat(p));\n        });\n    }\n    return rv;\n}\nfunction startsWith(str, prefix) {\n    return str.substr(0, prefix.length) == prefix;\n}\nfunction endsWith(str, suffix) {\n    return str.substr(str.length - suffix.length, suffix.length) == suffix;\n}\nfunction iso8601(d) {\n    if (typeof d == \"number\") d = new Date(d);\n    mod_assert.ok(d.constructor === Date);\n    return mod_extsprintf.sprintf(\"%4d-%02d-%02dT%02d:%02d:%02d.%03dZ\", d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());\n}\nvar RFC1123_MONTHS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nvar RFC1123_DAYS = [\n    \"Sun\",\n    \"Mon\",\n    \"Tue\",\n    \"Wed\",\n    \"Thu\",\n    \"Fri\",\n    \"Sat\"\n];\nfunction rfc1123(date) {\n    return mod_extsprintf.sprintf(\"%s, %02d %s %04d %02d:%02d:%02d GMT\", RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());\n}\n/*\n * Parses a date expressed as a string, as either a number of milliseconds since\n * the epoch or any string format that Date accepts, giving preference to the\n * former where these two sets overlap (e.g., small numbers).\n */ function parseDateTime(str) {\n    /*\n\t * This is irritatingly implicit, but significantly more concise than\n\t * alternatives.  The \"+str\" will convert a string containing only a\n\t * number directly to a Number, or NaN for other strings.  Thus, if the\n\t * conversion succeeds, we use it (this is the milliseconds-since-epoch\n\t * case).  Otherwise, we pass the string directly to the Date\n\t * constructor to parse.\n\t */ var numeric = +str;\n    if (!isNaN(numeric)) {\n        return new Date(numeric);\n    } else {\n        return new Date(str);\n    }\n}\n/*\n * Number.*_SAFE_INTEGER isn't present before node v0.12, so we hardcode\n * the ES6 definitions here, while allowing for them to someday be higher.\n */ var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\n/*\n * Default options for parseInteger().\n */ var PI_DEFAULTS = {\n    base: 10,\n    allowSign: true,\n    allowPrefix: false,\n    allowTrailing: false,\n    allowImprecise: false,\n    trimWhitespace: false,\n    leadingZeroIsOctal: false\n};\nvar CP_0 = 0x30;\nvar CP_9 = 0x39;\nvar CP_A = 0x41;\nvar CP_B = 0x42;\nvar CP_O = 0x4f;\nvar CP_T = 0x54;\nvar CP_X = 0x58;\nvar CP_Z = 0x5a;\nvar CP_a = 0x61;\nvar CP_b = 0x62;\nvar CP_o = 0x6f;\nvar CP_t = 0x74;\nvar CP_x = 0x78;\nvar CP_z = 0x7a;\nvar PI_CONV_DEC = 0x30;\nvar PI_CONV_UC = 0x37;\nvar PI_CONV_LC = 0x57;\n/*\n * A stricter version of parseInt() that provides options for changing what\n * is an acceptable string (for example, disallowing trailing characters).\n */ function parseInteger(str, uopts) {\n    mod_assert.string(str, \"str\");\n    mod_assert.optionalObject(uopts, \"options\");\n    var baseOverride = false;\n    var options = PI_DEFAULTS;\n    if (uopts) {\n        baseOverride = hasKey(uopts, \"base\");\n        options = mergeObjects(options, uopts);\n        mod_assert.number(options.base, \"options.base\");\n        mod_assert.ok(options.base >= 2, \"options.base >= 2\");\n        mod_assert.ok(options.base <= 36, \"options.base <= 36\");\n        mod_assert.bool(options.allowSign, \"options.allowSign\");\n        mod_assert.bool(options.allowPrefix, \"options.allowPrefix\");\n        mod_assert.bool(options.allowTrailing, \"options.allowTrailing\");\n        mod_assert.bool(options.allowImprecise, \"options.allowImprecise\");\n        mod_assert.bool(options.trimWhitespace, \"options.trimWhitespace\");\n        mod_assert.bool(options.leadingZeroIsOctal, \"options.leadingZeroIsOctal\");\n        if (options.leadingZeroIsOctal) {\n            mod_assert.ok(!baseOverride, '\"base\" and \"leadingZeroIsOctal\" are ' + \"mutually exclusive\");\n        }\n    }\n    var c;\n    var pbase = -1;\n    var base = options.base;\n    var start;\n    var mult = 1;\n    var value = 0;\n    var idx = 0;\n    var len = str.length;\n    /* Trim any whitespace on the left side. */ if (options.trimWhitespace) {\n        while(idx < len && isSpace(str.charCodeAt(idx))){\n            ++idx;\n        }\n    }\n    /* Check the number for a leading sign. */ if (options.allowSign) {\n        if (str[idx] === \"-\") {\n            idx += 1;\n            mult = -1;\n        } else if (str[idx] === \"+\") {\n            idx += 1;\n        }\n    }\n    /* Parse the base-indicating prefix if there is one. */ if (str[idx] === \"0\") {\n        if (options.allowPrefix) {\n            pbase = prefixToBase(str.charCodeAt(idx + 1));\n            if (pbase !== -1 && (!baseOverride || pbase === base)) {\n                base = pbase;\n                idx += 2;\n            }\n        }\n        if (pbase === -1 && options.leadingZeroIsOctal) {\n            base = 8;\n        }\n    }\n    /* Parse the actual digits. */ for(start = idx; idx < len; ++idx){\n        c = translateDigit(str.charCodeAt(idx));\n        if (c !== -1 && c < base) {\n            value *= base;\n            value += c;\n        } else {\n            break;\n        }\n    }\n    /* If we didn't parse any digits, we have an invalid number. */ if (start === idx) {\n        return new Error(\"invalid number: \" + JSON.stringify(str));\n    }\n    /* Trim any whitespace on the right side. */ if (options.trimWhitespace) {\n        while(idx < len && isSpace(str.charCodeAt(idx))){\n            ++idx;\n        }\n    }\n    /* Check for trailing characters. */ if (idx < len && !options.allowTrailing) {\n        return new Error(\"trailing characters after number: \" + JSON.stringify(str.slice(idx)));\n    }\n    /* If our value is 0, we return now, to avoid returning -0. */ if (value === 0) {\n        return 0;\n    }\n    /* Calculate our final value. */ var result = value * mult;\n    /*\n\t * If the string represents a value that cannot be precisely represented\n\t * by JavaScript, then we want to check that:\n\t *\n\t * - We never increased the value past MAX_SAFE_INTEGER\n\t * - We don't make the result negative and below MIN_SAFE_INTEGER\n\t *\n\t * Because we only ever increment the value during parsing, there's no\n\t * chance of moving past MAX_SAFE_INTEGER and then dropping below it\n\t * again, losing precision in the process. This means that we only need\n\t * to do our checks here, at the end.\n\t */ if (!options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {\n        return new Error(\"number is outside of the supported range: \" + JSON.stringify(str.slice(start, idx)));\n    }\n    return result;\n}\n/*\n * Interpret a character code as a base-36 digit.\n */ function translateDigit(d) {\n    if (d >= CP_0 && d <= CP_9) {\n        /* '0' to '9' -> 0 to 9 */ return d - PI_CONV_DEC;\n    } else if (d >= CP_A && d <= CP_Z) {\n        /* 'A' - 'Z' -> 10 to 35 */ return d - PI_CONV_UC;\n    } else if (d >= CP_a && d <= CP_z) {\n        /* 'a' - 'z' -> 10 to 35 */ return d - PI_CONV_LC;\n    } else {\n        /* Invalid character code */ return -1;\n    }\n}\n/*\n * Test if a value matches the ECMAScript definition of trimmable whitespace.\n */ function isSpace(c) {\n    return c === 0x20 || c >= 0x0009 && c <= 0x000d || c === 0x00a0 || c === 0x1680 || c === 0x180e || c >= 0x2000 && c <= 0x200a || c === 0x2028 || c === 0x2029 || c === 0x202f || c === 0x205f || c === 0x3000 || c === 0xfeff;\n}\n/*\n * Determine which base a character indicates (e.g., 'x' indicates hex).\n */ function prefixToBase(c) {\n    if (c === CP_b || c === CP_B) {\n        /* 0b/0B (binary) */ return 2;\n    } else if (c === CP_o || c === CP_O) {\n        /* 0o/0O (octal) */ return 8;\n    } else if (c === CP_t || c === CP_T) {\n        /* 0t/0T (decimal) */ return 10;\n    } else if (c === CP_x || c === CP_X) {\n        /* 0x/0X (hexadecimal) */ return 16;\n    } else {\n        /* Not a meaningful character */ return -1;\n    }\n}\nfunction validateJsonObjectJS(schema, input) {\n    var report = mod_jsonschema.validate(input, schema);\n    if (report.errors.length === 0) return null;\n    /* Currently, we only do anything useful with the first error. */ var error = report.errors[0];\n    /* The failed property is given by a URI with an irrelevant prefix. */ var propname = error[\"property\"];\n    var reason = error[\"message\"].toLowerCase();\n    var i, j;\n    /*\n\t * There's at least one case where the property error message is\n\t * confusing at best.  We work around this here.\n\t */ if ((i = reason.indexOf(\"the property \")) != -1 && (j = reason.indexOf(\" is not defined in the schema and the \" + \"schema does not allow additional properties\")) != -1) {\n        i += \"the property \".length;\n        if (propname === \"\") propname = reason.substr(i, j - i);\n        else propname = propname + \".\" + reason.substr(i, j - i);\n        reason = \"unsupported property\";\n    }\n    var rv = new mod_verror.VError('property \"%s\": %s', propname, reason);\n    rv.jsv_details = error;\n    return rv;\n}\nfunction randElt(arr) {\n    mod_assert.ok(Array.isArray(arr) && arr.length > 0, \"randElt argument must be a non-empty array\");\n    return arr[Math.floor(Math.random() * arr.length)];\n}\nfunction assertHrtime(a) {\n    mod_assert.ok(a[0] >= 0 && a[1] >= 0, \"negative numbers not allowed in hrtimes\");\n    mod_assert.ok(a[1] < 1e9, \"nanoseconds column overflow\");\n}\n/*\n * Compute the time elapsed between hrtime readings A and B, where A is later\n * than B.  hrtime readings come from Node's process.hrtime().  There is no\n * defined way to represent negative deltas, so it's illegal to diff B from A\n * where the time denoted by B is later than the time denoted by A.  If this\n * becomes valuable, we can define a representation and extend the\n * implementation to support it.\n */ function hrtimeDiff(a, b) {\n    assertHrtime(a);\n    assertHrtime(b);\n    mod_assert.ok(a[0] > b[0] || a[0] == b[0] && a[1] >= b[1], \"negative differences not allowed\");\n    var rv = [\n        a[0] - b[0],\n        0\n    ];\n    if (a[1] >= b[1]) {\n        rv[1] = a[1] - b[1];\n    } else {\n        rv[0]--;\n        rv[1] = 1e9 - (b[1] - a[1]);\n    }\n    return rv;\n}\n/*\n * Convert a hrtime reading from the array format returned by Node's\n * process.hrtime() into a scalar number of nanoseconds.\n */ function hrtimeNanosec(a) {\n    assertHrtime(a);\n    return Math.floor(a[0] * 1e9 + a[1]);\n}\n/*\n * Convert a hrtime reading from the array format returned by Node's\n * process.hrtime() into a scalar number of microseconds.\n */ function hrtimeMicrosec(a) {\n    assertHrtime(a);\n    return Math.floor(a[0] * 1e6 + a[1] / 1e3);\n}\n/*\n * Convert a hrtime reading from the array format returned by Node's\n * process.hrtime() into a scalar number of milliseconds.\n */ function hrtimeMillisec(a) {\n    assertHrtime(a);\n    return Math.floor(a[0] * 1e3 + a[1] / 1e6);\n}\n/*\n * Add two hrtime readings A and B, overwriting A with the result of the\n * addition.  This function is useful for accumulating several hrtime intervals\n * into a counter.  Returns A.\n */ function hrtimeAccum(a, b) {\n    assertHrtime(a);\n    assertHrtime(b);\n    /*\n\t * Accumulate the nanosecond component.\n\t */ a[1] += b[1];\n    if (a[1] >= 1e9) {\n        /*\n\t\t * The nanosecond component overflowed, so carry to the seconds\n\t\t * field.\n\t\t */ a[0]++;\n        a[1] -= 1e9;\n    }\n    /*\n\t * Accumulate the seconds component.\n\t */ a[0] += b[0];\n    return a;\n}\n/*\n * Add two hrtime readings A and B, returning the result as a new hrtime array.\n * Does not modify either input argument.\n */ function hrtimeAdd(a, b) {\n    assertHrtime(a);\n    var rv = [\n        a[0],\n        a[1]\n    ];\n    return hrtimeAccum(rv, b);\n}\n/*\n * Check an object for unexpected properties.  Accepts the object to check, and\n * an array of allowed property names (strings).  Returns an array of key names\n * that were found on the object, but did not appear in the list of allowed\n * properties.  If no properties were found, the returned array will be of\n * zero length.\n */ function extraProperties(obj, allowed) {\n    mod_assert.ok(typeof obj === \"object\" && obj !== null, \"obj argument must be a non-null object\");\n    mod_assert.ok(Array.isArray(allowed), \"allowed argument must be an array of strings\");\n    for(var i = 0; i < allowed.length; i++){\n        mod_assert.ok(typeof allowed[i] === \"string\", \"allowed argument must be an array of strings\");\n    }\n    return Object.keys(obj).filter(function(key) {\n        return allowed.indexOf(key) === -1;\n    });\n}\n/*\n * Given three sets of properties \"provided\" (may be undefined), \"overrides\"\n * (required), and \"defaults\" (may be undefined), construct an object containing\n * the union of these sets with \"overrides\" overriding \"provided\", and\n * \"provided\" overriding \"defaults\".  None of the input objects are modified.\n */ function mergeObjects(provided, overrides, defaults) {\n    var rv, k;\n    rv = {};\n    if (defaults) {\n        for(k in defaults)rv[k] = defaults[k];\n    }\n    if (provided) {\n        for(k in provided)rv[k] = provided[k];\n    }\n    if (overrides) {\n        for(k in overrides)rv[k] = overrides[k];\n    }\n    return rv;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qc3ByaW0vbGliL2pzcHJpbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCLElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUcsYUFBYUgsbUJBQU9BLENBQUM7QUFDekIsSUFBSUksaUJBQWlCSixtQkFBT0EsQ0FBQztBQUU3Qjs7Q0FFQyxHQUNESyxnQkFBZ0IsR0FBR0M7QUFDbkJELGlCQUFpQixHQUFHRTtBQUNwQkYsZUFBZSxHQUFHRztBQUNsQkgsY0FBYyxHQUFHSTtBQUNqQkosa0JBQWtCLEdBQUdLO0FBQ3JCTCxhQUFhLEdBQUdNO0FBQ2hCTixxQkFBcUIsR0FBR087QUFDeEJQLG1CQUFtQixHQUFHUTtBQUN0QlIsMEJBQTBCLEdBQUdVO0FBQzdCViw0QkFBNEIsR0FBR1U7QUFDL0JWLGVBQWUsR0FBR1c7QUFDbEJYLHVCQUF1QixHQUFHWTtBQUMxQlosb0JBQW9CLEdBQUdhO0FBRXZCYixrQkFBa0IsR0FBR2M7QUFDckJkLGdCQUFnQixHQUFHZTtBQUVuQmYsb0JBQW9CLEdBQUdnQjtBQUV2QmhCLGVBQWUsR0FBR2lCO0FBQ2xCakIsZUFBZSxHQUFHa0I7QUFDbEJsQixxQkFBcUIsR0FBR21CO0FBRXhCbkIsa0JBQWtCLEdBQUdxQjtBQUNyQnJCLGtCQUFrQixHQUFHcUI7QUFDckJyQixtQkFBbUIsR0FBR3NCO0FBQ3RCdEIsaUJBQWlCLEdBQUd1QjtBQUNwQnZCLHFCQUFxQixHQUFHd0I7QUFDeEJ4QixzQkFBc0IsR0FBR3lCO0FBQ3pCekIsc0JBQXNCLEdBQUcwQjtBQUd6Qjs7OztDQUlDLEdBQ0QsU0FBU3pCLFNBQVMwQixHQUFHO0lBRXBCLElBQUlDLEtBQUtDO0lBQ1QsSUFBSUMsU0FBUztJQUViLElBQUlILE9BQU9BLEdBQUcsQ0FBQ0csT0FBTyxFQUNy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QUNKLElBQUssSUFBSXZHLElBQUksR0FBR0EsSUFBSXVHLFFBQVFuSCxNQUFNLEVBQUVZLElBQUs7UUFDeENyRCxXQUFXK0QsRUFBRSxDQUFDLE9BQVE2RixPQUFPLENBQUN2RyxFQUFFLEtBQU0sVUFDbEM7SUFDTDtJQUVBLE9BQVFkLE9BQU9zSCxJQUFJLENBQUM1SCxLQUFLNkgsTUFBTSxDQUFDLFNBQVUzSCxHQUFHO1FBQzVDLE9BQVF5SCxRQUFRdEcsT0FBTyxDQUFDbkIsU0FBUyxDQUFDO0lBQ25DO0FBQ0Q7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNoQixhQUFhNEksUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFFBQVE7SUFFbEQsSUFBSWpHLElBQUluQjtJQUVSbUIsS0FBSyxDQUFDO0lBQ04sSUFBSWlHLFVBQVU7UUFDYixJQUFLcEgsS0FBS29ILFNBQ1RqRyxFQUFFLENBQUNuQixFQUFFLEdBQUdvSCxRQUFRLENBQUNwSCxFQUFFO0lBQ3JCO0lBRUEsSUFBSWtILFVBQVU7UUFDYixJQUFLbEgsS0FBS2tILFNBQ1QvRixFQUFFLENBQUNuQixFQUFFLEdBQUdrSCxRQUFRLENBQUNsSCxFQUFFO0lBQ3JCO0lBRUEsSUFBSW1ILFdBQVc7UUFDZCxJQUFLbkgsS0FBS21ILFVBQ1RoRyxFQUFFLENBQUNuQixFQUFFLEdBQUdtSCxTQUFTLENBQUNuSCxFQUFFO0lBQ3RCO0lBRUEsT0FBUW1CO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbm5vdmF0aW9uLWNvYWNoLy4vbm9kZV9tb2R1bGVzL2pzcHJpbS9saWIvanNwcmltLmpzPzBhZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGxpYi9qc3ByaW0uanM6IHV0aWxpdGllcyBmb3IgcHJpbWl0aXZlIEphdmFTY3JpcHQgdHlwZXNcbiAqL1xuXG52YXIgbW9kX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgbW9kX3V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBtb2RfZXh0c3ByaW50ZiA9IHJlcXVpcmUoJ2V4dHNwcmludGYnKTtcbnZhciBtb2RfdmVycm9yID0gcmVxdWlyZSgndmVycm9yJyk7XG52YXIgbW9kX2pzb25zY2hlbWEgPSByZXF1aXJlKCdqc29uLXNjaGVtYScpO1xuXG4vKlxuICogUHVibGljIGludGVyZmFjZVxuICovXG5leHBvcnRzLmRlZXBDb3B5ID0gZGVlcENvcHk7XG5leHBvcnRzLmRlZXBFcXVhbCA9IGRlZXBFcXVhbDtcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5leHBvcnRzLmhhc0tleSA9IGhhc0tleTtcbmV4cG9ydHMuZm9yRWFjaEtleSA9IGZvckVhY2hLZXk7XG5leHBvcnRzLnBsdWNrID0gcGx1Y2s7XG5leHBvcnRzLmZsYXR0ZW5PYmplY3QgPSBmbGF0dGVuT2JqZWN0O1xuZXhwb3J0cy5mbGF0dGVuSXRlciA9IGZsYXR0ZW5JdGVyO1xuZXhwb3J0cy52YWxpZGF0ZUpzb25PYmplY3QgPSB2YWxpZGF0ZUpzb25PYmplY3RKUztcbmV4cG9ydHMudmFsaWRhdGVKc29uT2JqZWN0SlMgPSB2YWxpZGF0ZUpzb25PYmplY3RKUztcbmV4cG9ydHMucmFuZEVsdCA9IHJhbmRFbHQ7XG5leHBvcnRzLmV4dHJhUHJvcGVydGllcyA9IGV4dHJhUHJvcGVydGllcztcbmV4cG9ydHMubWVyZ2VPYmplY3RzID0gbWVyZ2VPYmplY3RzO1xuXG5leHBvcnRzLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuZXhwb3J0cy5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuXG5leHBvcnRzLnBhcnNlSW50ZWdlciA9IHBhcnNlSW50ZWdlcjtcblxuZXhwb3J0cy5pc284NjAxID0gaXNvODYwMTtcbmV4cG9ydHMucmZjMTEyMyA9IHJmYzExMjM7XG5leHBvcnRzLnBhcnNlRGF0ZVRpbWUgPSBwYXJzZURhdGVUaW1lO1xuXG5leHBvcnRzLmhydGltZWRpZmYgPSBocnRpbWVEaWZmO1xuZXhwb3J0cy5ocnRpbWVEaWZmID0gaHJ0aW1lRGlmZjtcbmV4cG9ydHMuaHJ0aW1lQWNjdW0gPSBocnRpbWVBY2N1bTtcbmV4cG9ydHMuaHJ0aW1lQWRkID0gaHJ0aW1lQWRkO1xuZXhwb3J0cy5ocnRpbWVOYW5vc2VjID0gaHJ0aW1lTmFub3NlYztcbmV4cG9ydHMuaHJ0aW1lTWljcm9zZWMgPSBocnRpbWVNaWNyb3NlYztcbmV4cG9ydHMuaHJ0aW1lTWlsbGlzZWMgPSBocnRpbWVNaWxsaXNlYztcblxuXG4vKlxuICogRGVlcCBjb3B5IGFuIGFjeWNsaWMgKmJhc2ljKiBKYXZhc2NyaXB0IG9iamVjdC4gIFRoaXMgb25seSBoYW5kbGVzIGJhc2ljXG4gKiBzY2FsYXJzIChzdHJpbmdzLCBudW1iZXJzLCBib29sZWFucykgYW5kIGFyYml0cmFyaWx5IGRlZXAgYXJyYXlzIGFuZCBvYmplY3RzXG4gKiBjb250YWluaW5nIHRoZXNlLiAgVGhpcyBkb2VzICpub3QqIGhhbmRsZSBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3Nlcy5cbiAqL1xuZnVuY3Rpb24gZGVlcENvcHkob2JqKVxue1xuXHR2YXIgcmV0LCBrZXk7XG5cdHZhciBtYXJrZXIgPSAnX19kZWVwQ29weSc7XG5cblx0aWYgKG9iaiAmJiBvYmpbbWFya2VyXSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdhdHRlbXB0ZWQgZGVlcCBjb3B5IG9mIGN5Y2xpYyBvYmplY3QnKSk7XG5cblx0aWYgKG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT0gT2JqZWN0KSB7XG5cdFx0cmV0ID0ge307XG5cdFx0b2JqW21hcmtlcl0gPSB0cnVlO1xuXG5cdFx0Zm9yIChrZXkgaW4gb2JqKSB7XG5cdFx0XHRpZiAoa2V5ID09IG1hcmtlcilcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHJldFtrZXldID0gZGVlcENvcHkob2JqW2tleV0pO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSAob2JqW21hcmtlcl0pO1xuXHRcdHJldHVybiAocmV0KTtcblx0fVxuXG5cdGlmIChvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09IEFycmF5KSB7XG5cdFx0cmV0ID0gW107XG5cdFx0b2JqW21hcmtlcl0gPSB0cnVlO1xuXG5cdFx0Zm9yIChrZXkgPSAwOyBrZXkgPCBvYmoubGVuZ3RoOyBrZXkrKylcblx0XHRcdHJldC5wdXNoKGRlZXBDb3B5KG9ialtrZXldKSk7XG5cblx0XHRkZWxldGUgKG9ialttYXJrZXJdKTtcblx0XHRyZXR1cm4gKHJldCk7XG5cdH1cblxuXHQvKlxuXHQgKiBJdCBtdXN0IGJlIGEgcHJpbWl0aXZlIHR5cGUgLS0ganVzdCByZXR1cm4gaXQuXG5cdCAqL1xuXHRyZXR1cm4gKG9iaik7XG59XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChvYmoxLCBvYmoyKVxue1xuXHRpZiAodHlwZW9mIChvYmoxKSAhPSB0eXBlb2YgKG9iajIpKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXG5cdGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwgfHwgdHlwZW9mIChvYmoxKSAhPSAnb2JqZWN0Jylcblx0XHRyZXR1cm4gKG9iajEgPT09IG9iajIpO1xuXG5cdGlmIChvYmoxLmNvbnN0cnVjdG9yICE9IG9iajIuY29uc3RydWN0b3IpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cblx0dmFyIGs7XG5cdGZvciAoayBpbiBvYmoxKSB7XG5cdFx0aWYgKCFvYmoyLmhhc093blByb3BlcnR5KGspKVxuXHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cblx0XHRpZiAoIWRlZXBFcXVhbChvYmoxW2tdLCBvYmoyW2tdKSlcblx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHR9XG5cblx0Zm9yIChrIGluIG9iajIpIHtcblx0XHRpZiAoIW9iajEuaGFzT3duUHJvcGVydHkoaykpXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKVxue1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBvYmopXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGhhc0tleShvYmosIGtleSlcbntcblx0bW9kX2Fzc2VydC5lcXVhbCh0eXBlb2YgKGtleSksICdzdHJpbmcnKTtcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEtleShvYmosIGNhbGxiYWNrKVxue1xuXHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0aWYgKGhhc0tleShvYmosIGtleSkpIHtcblx0XHRcdGNhbGxiYWNrKGtleSwgb2JqW2tleV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwbHVjayhvYmosIGtleSlcbntcblx0bW9kX2Fzc2VydC5lcXVhbCh0eXBlb2YgKGtleSksICdzdHJpbmcnKTtcblx0cmV0dXJuIChwbHVja3Yob2JqLCBrZXkpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2t2KG9iaiwga2V5KVxue1xuXHRpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiAob2JqKSAhPT0gJ29iamVjdCcpXG5cdFx0cmV0dXJuICh1bmRlZmluZWQpO1xuXG5cdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSlcblx0XHRyZXR1cm4gKG9ialtrZXldKTtcblxuXHR2YXIgaSA9IGtleS5pbmRleE9mKCcuJyk7XG5cdGlmIChpID09IC0xKVxuXHRcdHJldHVybiAodW5kZWZpbmVkKTtcblxuXHR2YXIga2V5MSA9IGtleS5zdWJzdHIoMCwgaSk7XG5cdGlmICghb2JqLmhhc093blByb3BlcnR5KGtleTEpKVxuXHRcdHJldHVybiAodW5kZWZpbmVkKTtcblxuXHRyZXR1cm4gKHBsdWNrdihvYmpba2V5MV0sIGtleS5zdWJzdHIoaSArIDEpKSk7XG59XG5cbi8qXG4gKiBJbnZva2UgY2FsbGJhY2socm93KSBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBieVxuICogZmxhdHRlbk9iamVjdChkYXRhLCBkZXB0aCkuICBUaGlzIGlzIGp1c3QgbGlrZSBmbGF0dGVuT2JqZWN0KGRhdGEsXG4gKiBkZXB0aCkuZm9yRWFjaChjYWxsYmFjayksIGV4Y2VwdCB0aGF0IHRoZSBpbnRlcm1lZGlhdGUgYXJyYXkgaXMgbmV2ZXJcbiAqIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5JdGVyKGRhdGEsIGRlcHRoLCBjYWxsYmFjaylcbntcblx0ZG9GbGF0dGVuSXRlcihkYXRhLCBkZXB0aCwgW10sIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZG9GbGF0dGVuSXRlcihkYXRhLCBkZXB0aCwgYWNjdW0sIGNhbGxiYWNrKVxue1xuXHR2YXIgZWFjaDtcblx0dmFyIGtleTtcblxuXHRpZiAoZGVwdGggPT09IDApIHtcblx0XHRlYWNoID0gYWNjdW0uc2xpY2UoMCk7XG5cdFx0ZWFjaC5wdXNoKGRhdGEpO1xuXHRcdGNhbGxiYWNrKGVhY2gpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdG1vZF9hc3NlcnQub2soZGF0YSAhPT0gbnVsbCk7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChkYXRhKSwgJ29iamVjdCcpO1xuXHRtb2RfYXNzZXJ0LmVxdWFsKHR5cGVvZiAoZGVwdGgpLCAnbnVtYmVyJyk7XG5cdG1vZF9hc3NlcnQub2soZGVwdGggPj0gMCk7XG5cblx0Zm9yIChrZXkgaW4gZGF0YSkge1xuXHRcdGVhY2ggPSBhY2N1bS5zbGljZSgwKTtcblx0XHRlYWNoLnB1c2goa2V5KTtcblx0XHRkb0ZsYXR0ZW5JdGVyKGRhdGFba2V5XSwgZGVwdGggLSAxLCBlYWNoLCBjYWxsYmFjayk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbk9iamVjdChkYXRhLCBkZXB0aClcbntcblx0aWYgKGRlcHRoID09PSAwKVxuXHRcdHJldHVybiAoWyBkYXRhIF0pO1xuXG5cdG1vZF9hc3NlcnQub2soZGF0YSAhPT0gbnVsbCk7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChkYXRhKSwgJ29iamVjdCcpO1xuXHRtb2RfYXNzZXJ0LmVxdWFsKHR5cGVvZiAoZGVwdGgpLCAnbnVtYmVyJyk7XG5cdG1vZF9hc3NlcnQub2soZGVwdGggPj0gMCk7XG5cblx0dmFyIHJ2ID0gW107XG5cdHZhciBrZXk7XG5cblx0Zm9yIChrZXkgaW4gZGF0YSkge1xuXHRcdGZsYXR0ZW5PYmplY3QoZGF0YVtrZXldLCBkZXB0aCAtIDEpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcblx0XHRcdHJ2LnB1c2goWyBrZXkgXS5jb25jYXQocCkpO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIChydik7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpXG57XG5cdHJldHVybiAoc3RyLnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoKSA9PSBwcmVmaXgpO1xufVxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHN1ZmZpeClcbntcblx0cmV0dXJuIChzdHIuc3Vic3RyKFxuXHQgICAgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgsIHN1ZmZpeC5sZW5ndGgpID09IHN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIGlzbzg2MDEoZClcbntcblx0aWYgKHR5cGVvZiAoZCkgPT0gJ251bWJlcicpXG5cdFx0ZCA9IG5ldyBEYXRlKGQpO1xuXHRtb2RfYXNzZXJ0Lm9rKGQuY29uc3RydWN0b3IgPT09IERhdGUpO1xuXHRyZXR1cm4gKG1vZF9leHRzcHJpbnRmLnNwcmludGYoJyU0ZC0lMDJkLSUwMmRUJTAyZDolMDJkOiUwMmQuJTAzZFonLFxuXHQgICAgZC5nZXRVVENGdWxsWWVhcigpLCBkLmdldFVUQ01vbnRoKCkgKyAxLCBkLmdldFVUQ0RhdGUoKSxcblx0ICAgIGQuZ2V0VVRDSG91cnMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDU2Vjb25kcygpLFxuXHQgICAgZC5nZXRVVENNaWxsaXNlY29uZHMoKSkpO1xufVxuXG52YXIgUkZDMTEyM19NT05USFMgPSBbXG4gICAgJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcbiAgICAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbnZhciBSRkMxMTIzX0RBWVMgPSBbXG4gICAgJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddO1xuXG5mdW5jdGlvbiByZmMxMTIzKGRhdGUpIHtcblx0cmV0dXJuIChtb2RfZXh0c3ByaW50Zi5zcHJpbnRmKCclcywgJTAyZCAlcyAlMDRkICUwMmQ6JTAyZDolMDJkIEdNVCcsXG5cdCAgICBSRkMxMTIzX0RBWVNbZGF0ZS5nZXRVVENEYXkoKV0sIGRhdGUuZ2V0VVRDRGF0ZSgpLFxuXHQgICAgUkZDMTEyM19NT05USFNbZGF0ZS5nZXRVVENNb250aCgpXSwgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuXHQgICAgZGF0ZS5nZXRVVENIb3VycygpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcblx0ICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpKSk7XG59XG5cbi8qXG4gKiBQYXJzZXMgYSBkYXRlIGV4cHJlc3NlZCBhcyBhIHN0cmluZywgYXMgZWl0aGVyIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZVxuICogdGhlIGVwb2NoIG9yIGFueSBzdHJpbmcgZm9ybWF0IHRoYXQgRGF0ZSBhY2NlcHRzLCBnaXZpbmcgcHJlZmVyZW5jZSB0byB0aGVcbiAqIGZvcm1lciB3aGVyZSB0aGVzZSB0d28gc2V0cyBvdmVybGFwIChlLmcuLCBzbWFsbCBudW1iZXJzKS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VEYXRlVGltZShzdHIpXG57XG5cdC8qXG5cdCAqIFRoaXMgaXMgaXJyaXRhdGluZ2x5IGltcGxpY2l0LCBidXQgc2lnbmlmaWNhbnRseSBtb3JlIGNvbmNpc2UgdGhhblxuXHQgKiBhbHRlcm5hdGl2ZXMuICBUaGUgXCIrc3RyXCIgd2lsbCBjb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgb25seSBhXG5cdCAqIG51bWJlciBkaXJlY3RseSB0byBhIE51bWJlciwgb3IgTmFOIGZvciBvdGhlciBzdHJpbmdzLiAgVGh1cywgaWYgdGhlXG5cdCAqIGNvbnZlcnNpb24gc3VjY2VlZHMsIHdlIHVzZSBpdCAodGhpcyBpcyB0aGUgbWlsbGlzZWNvbmRzLXNpbmNlLWVwb2NoXG5cdCAqIGNhc2UpLiAgT3RoZXJ3aXNlLCB3ZSBwYXNzIHRoZSBzdHJpbmcgZGlyZWN0bHkgdG8gdGhlIERhdGVcblx0ICogY29uc3RydWN0b3IgdG8gcGFyc2UuXG5cdCAqL1xuXHR2YXIgbnVtZXJpYyA9ICtzdHI7XG5cdGlmICghaXNOYU4obnVtZXJpYykpIHtcblx0XHRyZXR1cm4gKG5ldyBEYXRlKG51bWVyaWMpKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gKG5ldyBEYXRlKHN0cikpO1xuXHR9XG59XG5cblxuLypcbiAqIE51bWJlci4qX1NBRkVfSU5URUdFUiBpc24ndCBwcmVzZW50IGJlZm9yZSBub2RlIHYwLjEyLCBzbyB3ZSBoYXJkY29kZVxuICogdGhlIEVTNiBkZWZpbml0aW9ucyBoZXJlLCB3aGlsZSBhbGxvd2luZyBmb3IgdGhlbSB0byBzb21lZGF5IGJlIGhpZ2hlci5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIE1JTl9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcblxuXG4vKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzZUludGVnZXIoKS5cbiAqL1xudmFyIFBJX0RFRkFVTFRTID0ge1xuXHRiYXNlOiAxMCxcblx0YWxsb3dTaWduOiB0cnVlLFxuXHRhbGxvd1ByZWZpeDogZmFsc2UsXG5cdGFsbG93VHJhaWxpbmc6IGZhbHNlLFxuXHRhbGxvd0ltcHJlY2lzZTogZmFsc2UsXG5cdHRyaW1XaGl0ZXNwYWNlOiBmYWxzZSxcblx0bGVhZGluZ1plcm9Jc09jdGFsOiBmYWxzZVxufTtcblxudmFyIENQXzAgPSAweDMwO1xudmFyIENQXzkgPSAweDM5O1xuXG52YXIgQ1BfQSA9IDB4NDE7XG52YXIgQ1BfQiA9IDB4NDI7XG52YXIgQ1BfTyA9IDB4NGY7XG52YXIgQ1BfVCA9IDB4NTQ7XG52YXIgQ1BfWCA9IDB4NTg7XG52YXIgQ1BfWiA9IDB4NWE7XG5cbnZhciBDUF9hID0gMHg2MTtcbnZhciBDUF9iID0gMHg2MjtcbnZhciBDUF9vID0gMHg2ZjtcbnZhciBDUF90ID0gMHg3NDtcbnZhciBDUF94ID0gMHg3ODtcbnZhciBDUF96ID0gMHg3YTtcblxudmFyIFBJX0NPTlZfREVDID0gMHgzMDtcbnZhciBQSV9DT05WX1VDID0gMHgzNztcbnZhciBQSV9DT05WX0xDID0gMHg1NztcblxuXG4vKlxuICogQSBzdHJpY3RlciB2ZXJzaW9uIG9mIHBhcnNlSW50KCkgdGhhdCBwcm92aWRlcyBvcHRpb25zIGZvciBjaGFuZ2luZyB3aGF0XG4gKiBpcyBhbiBhY2NlcHRhYmxlIHN0cmluZyAoZm9yIGV4YW1wbGUsIGRpc2FsbG93aW5nIHRyYWlsaW5nIGNoYXJhY3RlcnMpLlxuICovXG5mdW5jdGlvbiBwYXJzZUludGVnZXIoc3RyLCB1b3B0cylcbntcblx0bW9kX2Fzc2VydC5zdHJpbmcoc3RyLCAnc3RyJyk7XG5cdG1vZF9hc3NlcnQub3B0aW9uYWxPYmplY3QodW9wdHMsICdvcHRpb25zJyk7XG5cblx0dmFyIGJhc2VPdmVycmlkZSA9IGZhbHNlO1xuXHR2YXIgb3B0aW9ucyA9IFBJX0RFRkFVTFRTO1xuXG5cdGlmICh1b3B0cykge1xuXHRcdGJhc2VPdmVycmlkZSA9IGhhc0tleSh1b3B0cywgJ2Jhc2UnKTtcblx0XHRvcHRpb25zID0gbWVyZ2VPYmplY3RzKG9wdGlvbnMsIHVvcHRzKTtcblx0XHRtb2RfYXNzZXJ0Lm51bWJlcihvcHRpb25zLmJhc2UsICdvcHRpb25zLmJhc2UnKTtcblx0XHRtb2RfYXNzZXJ0Lm9rKG9wdGlvbnMuYmFzZSA+PSAyLCAnb3B0aW9ucy5iYXNlID49IDInKTtcblx0XHRtb2RfYXNzZXJ0Lm9rKG9wdGlvbnMuYmFzZSA8PSAzNiwgJ29wdGlvbnMuYmFzZSA8PSAzNicpO1xuXHRcdG1vZF9hc3NlcnQuYm9vbChvcHRpb25zLmFsbG93U2lnbiwgJ29wdGlvbnMuYWxsb3dTaWduJyk7XG5cdFx0bW9kX2Fzc2VydC5ib29sKG9wdGlvbnMuYWxsb3dQcmVmaXgsICdvcHRpb25zLmFsbG93UHJlZml4Jyk7XG5cdFx0bW9kX2Fzc2VydC5ib29sKG9wdGlvbnMuYWxsb3dUcmFpbGluZyxcblx0XHQgICAgJ29wdGlvbnMuYWxsb3dUcmFpbGluZycpO1xuXHRcdG1vZF9hc3NlcnQuYm9vbChvcHRpb25zLmFsbG93SW1wcmVjaXNlLFxuXHRcdCAgICAnb3B0aW9ucy5hbGxvd0ltcHJlY2lzZScpO1xuXHRcdG1vZF9hc3NlcnQuYm9vbChvcHRpb25zLnRyaW1XaGl0ZXNwYWNlLFxuXHRcdCAgICAnb3B0aW9ucy50cmltV2hpdGVzcGFjZScpO1xuXHRcdG1vZF9hc3NlcnQuYm9vbChvcHRpb25zLmxlYWRpbmdaZXJvSXNPY3RhbCxcblx0XHQgICAgJ29wdGlvbnMubGVhZGluZ1plcm9Jc09jdGFsJyk7XG5cblx0XHRpZiAob3B0aW9ucy5sZWFkaW5nWmVyb0lzT2N0YWwpIHtcblx0XHRcdG1vZF9hc3NlcnQub2soIWJhc2VPdmVycmlkZSxcblx0XHRcdCAgICAnXCJiYXNlXCIgYW5kIFwibGVhZGluZ1plcm9Jc09jdGFsXCIgYXJlICcgK1xuXHRcdFx0ICAgICdtdXR1YWxseSBleGNsdXNpdmUnKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgYztcblx0dmFyIHBiYXNlID0gLTE7XG5cdHZhciBiYXNlID0gb3B0aW9ucy5iYXNlO1xuXHR2YXIgc3RhcnQ7XG5cdHZhciBtdWx0ID0gMTtcblx0dmFyIHZhbHVlID0gMDtcblx0dmFyIGlkeCA9IDA7XG5cdHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXG5cdC8qIFRyaW0gYW55IHdoaXRlc3BhY2Ugb24gdGhlIGxlZnQgc2lkZS4gKi9cblx0aWYgKG9wdGlvbnMudHJpbVdoaXRlc3BhY2UpIHtcblx0XHR3aGlsZSAoaWR4IDwgbGVuICYmIGlzU3BhY2Uoc3RyLmNoYXJDb2RlQXQoaWR4KSkpIHtcblx0XHRcdCsraWR4O1xuXHRcdH1cblx0fVxuXG5cdC8qIENoZWNrIHRoZSBudW1iZXIgZm9yIGEgbGVhZGluZyBzaWduLiAqL1xuXHRpZiAob3B0aW9ucy5hbGxvd1NpZ24pIHtcblx0XHRpZiAoc3RyW2lkeF0gPT09ICctJykge1xuXHRcdFx0aWR4ICs9IDE7XG5cdFx0XHRtdWx0ID0gLTE7XG5cdFx0fSBlbHNlIGlmIChzdHJbaWR4XSA9PT0gJysnKSB7XG5cdFx0XHRpZHggKz0gMTtcblx0XHR9XG5cdH1cblxuXHQvKiBQYXJzZSB0aGUgYmFzZS1pbmRpY2F0aW5nIHByZWZpeCBpZiB0aGVyZSBpcyBvbmUuICovXG5cdGlmIChzdHJbaWR4XSA9PT0gJzAnKSB7XG5cdFx0aWYgKG9wdGlvbnMuYWxsb3dQcmVmaXgpIHtcblx0XHRcdHBiYXNlID0gcHJlZml4VG9CYXNlKHN0ci5jaGFyQ29kZUF0KGlkeCArIDEpKTtcblx0XHRcdGlmIChwYmFzZSAhPT0gLTEgJiYgKCFiYXNlT3ZlcnJpZGUgfHwgcGJhc2UgPT09IGJhc2UpKSB7XG5cdFx0XHRcdGJhc2UgPSBwYmFzZTtcblx0XHRcdFx0aWR4ICs9IDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHBiYXNlID09PSAtMSAmJiBvcHRpb25zLmxlYWRpbmdaZXJvSXNPY3RhbCkge1xuXHRcdFx0YmFzZSA9IDg7XG5cdFx0fVxuXHR9XG5cblx0LyogUGFyc2UgdGhlIGFjdHVhbCBkaWdpdHMuICovXG5cdGZvciAoc3RhcnQgPSBpZHg7IGlkeCA8IGxlbjsgKytpZHgpIHtcblx0XHRjID0gdHJhbnNsYXRlRGlnaXQoc3RyLmNoYXJDb2RlQXQoaWR4KSk7XG5cdFx0aWYgKGMgIT09IC0xICYmIGMgPCBiYXNlKSB7XG5cdFx0XHR2YWx1ZSAqPSBiYXNlO1xuXHRcdFx0dmFsdWUgKz0gYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0LyogSWYgd2UgZGlkbid0IHBhcnNlIGFueSBkaWdpdHMsIHdlIGhhdmUgYW4gaW52YWxpZCBudW1iZXIuICovXG5cdGlmIChzdGFydCA9PT0gaWR4KSB7XG5cdFx0cmV0dXJuIChuZXcgRXJyb3IoJ2ludmFsaWQgbnVtYmVyOiAnICsgSlNPTi5zdHJpbmdpZnkoc3RyKSkpO1xuXHR9XG5cblx0LyogVHJpbSBhbnkgd2hpdGVzcGFjZSBvbiB0aGUgcmlnaHQgc2lkZS4gKi9cblx0aWYgKG9wdGlvbnMudHJpbVdoaXRlc3BhY2UpIHtcblx0XHR3aGlsZSAoaWR4IDwgbGVuICYmIGlzU3BhY2Uoc3RyLmNoYXJDb2RlQXQoaWR4KSkpIHtcblx0XHRcdCsraWR4O1xuXHRcdH1cblx0fVxuXG5cdC8qIENoZWNrIGZvciB0cmFpbGluZyBjaGFyYWN0ZXJzLiAqL1xuXHRpZiAoaWR4IDwgbGVuICYmICFvcHRpb25zLmFsbG93VHJhaWxpbmcpIHtcblx0XHRyZXR1cm4gKG5ldyBFcnJvcigndHJhaWxpbmcgY2hhcmFjdGVycyBhZnRlciBudW1iZXI6ICcgK1xuXHRcdCAgICBKU09OLnN0cmluZ2lmeShzdHIuc2xpY2UoaWR4KSkpKTtcblx0fVxuXG5cdC8qIElmIG91ciB2YWx1ZSBpcyAwLCB3ZSByZXR1cm4gbm93LCB0byBhdm9pZCByZXR1cm5pbmcgLTAuICovXG5cdGlmICh2YWx1ZSA9PT0gMCkge1xuXHRcdHJldHVybiAoMCk7XG5cdH1cblxuXHQvKiBDYWxjdWxhdGUgb3VyIGZpbmFsIHZhbHVlLiAqL1xuXHR2YXIgcmVzdWx0ID0gdmFsdWUgKiBtdWx0O1xuXG5cdC8qXG5cdCAqIElmIHRoZSBzdHJpbmcgcmVwcmVzZW50cyBhIHZhbHVlIHRoYXQgY2Fubm90IGJlIHByZWNpc2VseSByZXByZXNlbnRlZFxuXHQgKiBieSBKYXZhU2NyaXB0LCB0aGVuIHdlIHdhbnQgdG8gY2hlY2sgdGhhdDpcblx0ICpcblx0ICogLSBXZSBuZXZlciBpbmNyZWFzZWQgdGhlIHZhbHVlIHBhc3QgTUFYX1NBRkVfSU5URUdFUlxuXHQgKiAtIFdlIGRvbid0IG1ha2UgdGhlIHJlc3VsdCBuZWdhdGl2ZSBhbmQgYmVsb3cgTUlOX1NBRkVfSU5URUdFUlxuXHQgKlxuXHQgKiBCZWNhdXNlIHdlIG9ubHkgZXZlciBpbmNyZW1lbnQgdGhlIHZhbHVlIGR1cmluZyBwYXJzaW5nLCB0aGVyZSdzIG5vXG5cdCAqIGNoYW5jZSBvZiBtb3ZpbmcgcGFzdCBNQVhfU0FGRV9JTlRFR0VSIGFuZCB0aGVuIGRyb3BwaW5nIGJlbG93IGl0XG5cdCAqIGFnYWluLCBsb3NpbmcgcHJlY2lzaW9uIGluIHRoZSBwcm9jZXNzLiBUaGlzIG1lYW5zIHRoYXQgd2Ugb25seSBuZWVkXG5cdCAqIHRvIGRvIG91ciBjaGVja3MgaGVyZSwgYXQgdGhlIGVuZC5cblx0ICovXG5cdGlmICghb3B0aW9ucy5hbGxvd0ltcHJlY2lzZSAmJlxuXHQgICAgKHZhbHVlID4gTUFYX1NBRkVfSU5URUdFUiB8fCByZXN1bHQgPCBNSU5fU0FGRV9JTlRFR0VSKSkge1xuXHRcdHJldHVybiAobmV3IEVycm9yKCdudW1iZXIgaXMgb3V0c2lkZSBvZiB0aGUgc3VwcG9ydGVkIHJhbmdlOiAnICtcblx0XHQgICAgSlNPTi5zdHJpbmdpZnkoc3RyLnNsaWNlKHN0YXJ0LCBpZHgpKSkpO1xuXHR9XG5cblx0cmV0dXJuIChyZXN1bHQpO1xufVxuXG5cbi8qXG4gKiBJbnRlcnByZXQgYSBjaGFyYWN0ZXIgY29kZSBhcyBhIGJhc2UtMzYgZGlnaXQuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZURpZ2l0KGQpXG57XG5cdGlmIChkID49IENQXzAgJiYgZCA8PSBDUF85KSB7XG5cdFx0LyogJzAnIHRvICc5JyAtPiAwIHRvIDkgKi9cblx0XHRyZXR1cm4gKGQgLSBQSV9DT05WX0RFQyk7XG5cdH0gZWxzZSBpZiAoZCA+PSBDUF9BICYmIGQgPD0gQ1BfWikge1xuXHRcdC8qICdBJyAtICdaJyAtPiAxMCB0byAzNSAqL1xuXHRcdHJldHVybiAoZCAtIFBJX0NPTlZfVUMpO1xuXHR9IGVsc2UgaWYgKGQgPj0gQ1BfYSAmJiBkIDw9IENQX3opIHtcblx0XHQvKiAnYScgLSAneicgLT4gMTAgdG8gMzUgKi9cblx0XHRyZXR1cm4gKGQgLSBQSV9DT05WX0xDKTtcblx0fSBlbHNlIHtcblx0XHQvKiBJbnZhbGlkIGNoYXJhY3RlciBjb2RlICovXG5cdFx0cmV0dXJuICgtMSk7XG5cdH1cbn1cblxuXG4vKlxuICogVGVzdCBpZiBhIHZhbHVlIG1hdGNoZXMgdGhlIEVDTUFTY3JpcHQgZGVmaW5pdGlvbiBvZiB0cmltbWFibGUgd2hpdGVzcGFjZS5cbiAqL1xuZnVuY3Rpb24gaXNTcGFjZShjKVxue1xuXHRyZXR1cm4gKGMgPT09IDB4MjApIHx8XG5cdCAgICAoYyA+PSAweDAwMDkgJiYgYyA8PSAweDAwMGQpIHx8XG5cdCAgICAoYyA9PT0gMHgwMGEwKSB8fFxuXHQgICAgKGMgPT09IDB4MTY4MCkgfHxcblx0ICAgIChjID09PSAweDE4MGUpIHx8XG5cdCAgICAoYyA+PSAweDIwMDAgJiYgYyA8PSAweDIwMGEpIHx8XG5cdCAgICAoYyA9PT0gMHgyMDI4KSB8fFxuXHQgICAgKGMgPT09IDB4MjAyOSkgfHxcblx0ICAgIChjID09PSAweDIwMmYpIHx8XG5cdCAgICAoYyA9PT0gMHgyMDVmKSB8fFxuXHQgICAgKGMgPT09IDB4MzAwMCkgfHxcblx0ICAgIChjID09PSAweGZlZmYpO1xufVxuXG5cbi8qXG4gKiBEZXRlcm1pbmUgd2hpY2ggYmFzZSBhIGNoYXJhY3RlciBpbmRpY2F0ZXMgKGUuZy4sICd4JyBpbmRpY2F0ZXMgaGV4KS5cbiAqL1xuZnVuY3Rpb24gcHJlZml4VG9CYXNlKGMpXG57XG5cdGlmIChjID09PSBDUF9iIHx8IGMgPT09IENQX0IpIHtcblx0XHQvKiAwYi8wQiAoYmluYXJ5KSAqL1xuXHRcdHJldHVybiAoMik7XG5cdH0gZWxzZSBpZiAoYyA9PT0gQ1BfbyB8fCBjID09PSBDUF9PKSB7XG5cdFx0LyogMG8vME8gKG9jdGFsKSAqL1xuXHRcdHJldHVybiAoOCk7XG5cdH0gZWxzZSBpZiAoYyA9PT0gQ1BfdCB8fCBjID09PSBDUF9UKSB7XG5cdFx0LyogMHQvMFQgKGRlY2ltYWwpICovXG5cdFx0cmV0dXJuICgxMCk7XG5cdH0gZWxzZSBpZiAoYyA9PT0gQ1BfeCB8fCBjID09PSBDUF9YKSB7XG5cdFx0LyogMHgvMFggKGhleGFkZWNpbWFsKSAqL1xuXHRcdHJldHVybiAoMTYpO1xuXHR9IGVsc2Uge1xuXHRcdC8qIE5vdCBhIG1lYW5pbmdmdWwgY2hhcmFjdGVyICovXG5cdFx0cmV0dXJuICgtMSk7XG5cdH1cbn1cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUpzb25PYmplY3RKUyhzY2hlbWEsIGlucHV0KVxue1xuXHR2YXIgcmVwb3J0ID0gbW9kX2pzb25zY2hlbWEudmFsaWRhdGUoaW5wdXQsIHNjaGVtYSk7XG5cblx0aWYgKHJlcG9ydC5lcnJvcnMubGVuZ3RoID09PSAwKVxuXHRcdHJldHVybiAobnVsbCk7XG5cblx0LyogQ3VycmVudGx5LCB3ZSBvbmx5IGRvIGFueXRoaW5nIHVzZWZ1bCB3aXRoIHRoZSBmaXJzdCBlcnJvci4gKi9cblx0dmFyIGVycm9yID0gcmVwb3J0LmVycm9yc1swXTtcblxuXHQvKiBUaGUgZmFpbGVkIHByb3BlcnR5IGlzIGdpdmVuIGJ5IGEgVVJJIHdpdGggYW4gaXJyZWxldmFudCBwcmVmaXguICovXG5cdHZhciBwcm9wbmFtZSA9IGVycm9yWydwcm9wZXJ0eSddO1xuXHR2YXIgcmVhc29uID0gZXJyb3JbJ21lc3NhZ2UnXS50b0xvd2VyQ2FzZSgpO1xuXHR2YXIgaSwgajtcblxuXHQvKlxuXHQgKiBUaGVyZSdzIGF0IGxlYXN0IG9uZSBjYXNlIHdoZXJlIHRoZSBwcm9wZXJ0eSBlcnJvciBtZXNzYWdlIGlzXG5cdCAqIGNvbmZ1c2luZyBhdCBiZXN0LiAgV2Ugd29yayBhcm91bmQgdGhpcyBoZXJlLlxuXHQgKi9cblx0aWYgKChpID0gcmVhc29uLmluZGV4T2YoJ3RoZSBwcm9wZXJ0eSAnKSkgIT0gLTEgJiZcblx0ICAgIChqID0gcmVhc29uLmluZGV4T2YoJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgc2NoZW1hIGFuZCB0aGUgJyArXG5cdCAgICAnc2NoZW1hIGRvZXMgbm90IGFsbG93IGFkZGl0aW9uYWwgcHJvcGVydGllcycpKSAhPSAtMSkge1xuXHRcdGkgKz0gJ3RoZSBwcm9wZXJ0eSAnLmxlbmd0aDtcblx0XHRpZiAocHJvcG5hbWUgPT09ICcnKVxuXHRcdFx0cHJvcG5hbWUgPSByZWFzb24uc3Vic3RyKGksIGogLSBpKTtcblx0XHRlbHNlXG5cdFx0XHRwcm9wbmFtZSA9IHByb3BuYW1lICsgJy4nICsgcmVhc29uLnN1YnN0cihpLCBqIC0gaSk7XG5cblx0XHRyZWFzb24gPSAndW5zdXBwb3J0ZWQgcHJvcGVydHknO1xuXHR9XG5cblx0dmFyIHJ2ID0gbmV3IG1vZF92ZXJyb3IuVkVycm9yKCdwcm9wZXJ0eSBcIiVzXCI6ICVzJywgcHJvcG5hbWUsIHJlYXNvbik7XG5cdHJ2Lmpzdl9kZXRhaWxzID0gZXJyb3I7XG5cdHJldHVybiAocnYpO1xufVxuXG5mdW5jdGlvbiByYW5kRWx0KGFycilcbntcblx0bW9kX2Fzc2VydC5vayhBcnJheS5pc0FycmF5KGFycikgJiYgYXJyLmxlbmd0aCA+IDAsXG5cdCAgICAncmFuZEVsdCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5Jyk7XG5cblx0cmV0dXJuIChhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SHJ0aW1lKGEpXG57XG5cdG1vZF9hc3NlcnQub2soYVswXSA+PSAwICYmIGFbMV0gPj0gMCxcblx0ICAgICduZWdhdGl2ZSBudW1iZXJzIG5vdCBhbGxvd2VkIGluIGhydGltZXMnKTtcblx0bW9kX2Fzc2VydC5vayhhWzFdIDwgMWU5LCAnbmFub3NlY29uZHMgY29sdW1uIG92ZXJmbG93Jyk7XG59XG5cbi8qXG4gKiBDb21wdXRlIHRoZSB0aW1lIGVsYXBzZWQgYmV0d2VlbiBocnRpbWUgcmVhZGluZ3MgQSBhbmQgQiwgd2hlcmUgQSBpcyBsYXRlclxuICogdGhhbiBCLiAgaHJ0aW1lIHJlYWRpbmdzIGNvbWUgZnJvbSBOb2RlJ3MgcHJvY2Vzcy5ocnRpbWUoKS4gIFRoZXJlIGlzIG5vXG4gKiBkZWZpbmVkIHdheSB0byByZXByZXNlbnQgbmVnYXRpdmUgZGVsdGFzLCBzbyBpdCdzIGlsbGVnYWwgdG8gZGlmZiBCIGZyb20gQVxuICogd2hlcmUgdGhlIHRpbWUgZGVub3RlZCBieSBCIGlzIGxhdGVyIHRoYW4gdGhlIHRpbWUgZGVub3RlZCBieSBBLiAgSWYgdGhpc1xuICogYmVjb21lcyB2YWx1YWJsZSwgd2UgY2FuIGRlZmluZSBhIHJlcHJlc2VudGF0aW9uIGFuZCBleHRlbmQgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiB0byBzdXBwb3J0IGl0LlxuICovXG5mdW5jdGlvbiBocnRpbWVEaWZmKGEsIGIpXG57XG5cdGFzc2VydEhydGltZShhKTtcblx0YXNzZXJ0SHJ0aW1lKGIpO1xuXHRtb2RfYXNzZXJ0Lm9rKGFbMF0gPiBiWzBdIHx8IChhWzBdID09IGJbMF0gJiYgYVsxXSA+PSBiWzFdKSxcblx0ICAgICduZWdhdGl2ZSBkaWZmZXJlbmNlcyBub3QgYWxsb3dlZCcpO1xuXG5cdHZhciBydiA9IFsgYVswXSAtIGJbMF0sIDAgXTtcblxuXHRpZiAoYVsxXSA+PSBiWzFdKSB7XG5cdFx0cnZbMV0gPSBhWzFdIC0gYlsxXTtcblx0fSBlbHNlIHtcblx0XHRydlswXS0tO1xuXHRcdHJ2WzFdID0gMWU5IC0gKGJbMV0gLSBhWzFdKTtcblx0fVxuXG5cdHJldHVybiAocnYpO1xufVxuXG4vKlxuICogQ29udmVydCBhIGhydGltZSByZWFkaW5nIGZyb20gdGhlIGFycmF5IGZvcm1hdCByZXR1cm5lZCBieSBOb2RlJ3NcbiAqIHByb2Nlc3MuaHJ0aW1lKCkgaW50byBhIHNjYWxhciBudW1iZXIgb2YgbmFub3NlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIGhydGltZU5hbm9zZWMoYSlcbntcblx0YXNzZXJ0SHJ0aW1lKGEpO1xuXG5cdHJldHVybiAoTWF0aC5mbG9vcihhWzBdICogMWU5ICsgYVsxXSkpO1xufVxuXG4vKlxuICogQ29udmVydCBhIGhydGltZSByZWFkaW5nIGZyb20gdGhlIGFycmF5IGZvcm1hdCByZXR1cm5lZCBieSBOb2RlJ3NcbiAqIHByb2Nlc3MuaHJ0aW1lKCkgaW50byBhIHNjYWxhciBudW1iZXIgb2YgbWljcm9zZWNvbmRzLlxuICovXG5mdW5jdGlvbiBocnRpbWVNaWNyb3NlYyhhKVxue1xuXHRhc3NlcnRIcnRpbWUoYSk7XG5cblx0cmV0dXJuIChNYXRoLmZsb29yKGFbMF0gKiAxZTYgKyBhWzFdIC8gMWUzKSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgaHJ0aW1lIHJlYWRpbmcgZnJvbSB0aGUgYXJyYXkgZm9ybWF0IHJldHVybmVkIGJ5IE5vZGUnc1xuICogcHJvY2Vzcy5ocnRpbWUoKSBpbnRvIGEgc2NhbGFyIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIGhydGltZU1pbGxpc2VjKGEpXG57XG5cdGFzc2VydEhydGltZShhKTtcblxuXHRyZXR1cm4gKE1hdGguZmxvb3IoYVswXSAqIDFlMyArIGFbMV0gLyAxZTYpKTtcbn1cblxuLypcbiAqIEFkZCB0d28gaHJ0aW1lIHJlYWRpbmdzIEEgYW5kIEIsIG92ZXJ3cml0aW5nIEEgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZVxuICogYWRkaXRpb24uICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBmb3IgYWNjdW11bGF0aW5nIHNldmVyYWwgaHJ0aW1lIGludGVydmFsc1xuICogaW50byBhIGNvdW50ZXIuICBSZXR1cm5zIEEuXG4gKi9cbmZ1bmN0aW9uIGhydGltZUFjY3VtKGEsIGIpXG57XG5cdGFzc2VydEhydGltZShhKTtcblx0YXNzZXJ0SHJ0aW1lKGIpO1xuXG5cdC8qXG5cdCAqIEFjY3VtdWxhdGUgdGhlIG5hbm9zZWNvbmQgY29tcG9uZW50LlxuXHQgKi9cblx0YVsxXSArPSBiWzFdO1xuXHRpZiAoYVsxXSA+PSAxZTkpIHtcblx0XHQvKlxuXHRcdCAqIFRoZSBuYW5vc2Vjb25kIGNvbXBvbmVudCBvdmVyZmxvd2VkLCBzbyBjYXJyeSB0byB0aGUgc2Vjb25kc1xuXHRcdCAqIGZpZWxkLlxuXHRcdCAqL1xuXHRcdGFbMF0rKztcblx0XHRhWzFdIC09IDFlOTtcblx0fVxuXG5cdC8qXG5cdCAqIEFjY3VtdWxhdGUgdGhlIHNlY29uZHMgY29tcG9uZW50LlxuXHQgKi9cblx0YVswXSArPSBiWzBdO1xuXG5cdHJldHVybiAoYSk7XG59XG5cbi8qXG4gKiBBZGQgdHdvIGhydGltZSByZWFkaW5ncyBBIGFuZCBCLCByZXR1cm5pbmcgdGhlIHJlc3VsdCBhcyBhIG5ldyBocnRpbWUgYXJyYXkuXG4gKiBEb2VzIG5vdCBtb2RpZnkgZWl0aGVyIGlucHV0IGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBocnRpbWVBZGQoYSwgYilcbntcblx0YXNzZXJ0SHJ0aW1lKGEpO1xuXG5cdHZhciBydiA9IFsgYVswXSwgYVsxXSBdO1xuXG5cdHJldHVybiAoaHJ0aW1lQWNjdW0ocnYsIGIpKTtcbn1cblxuXG4vKlxuICogQ2hlY2sgYW4gb2JqZWN0IGZvciB1bmV4cGVjdGVkIHByb3BlcnRpZXMuICBBY2NlcHRzIHRoZSBvYmplY3QgdG8gY2hlY2ssIGFuZFxuICogYW4gYXJyYXkgb2YgYWxsb3dlZCBwcm9wZXJ0eSBuYW1lcyAoc3RyaW5ncykuICBSZXR1cm5zIGFuIGFycmF5IG9mIGtleSBuYW1lc1xuICogdGhhdCB3ZXJlIGZvdW5kIG9uIHRoZSBvYmplY3QsIGJ1dCBkaWQgbm90IGFwcGVhciBpbiB0aGUgbGlzdCBvZiBhbGxvd2VkXG4gKiBwcm9wZXJ0aWVzLiAgSWYgbm8gcHJvcGVydGllcyB3ZXJlIGZvdW5kLCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBiZSBvZlxuICogemVybyBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGV4dHJhUHJvcGVydGllcyhvYmosIGFsbG93ZWQpXG57XG5cdG1vZF9hc3NlcnQub2sodHlwZW9mIChvYmopID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwsXG5cdCAgICAnb2JqIGFyZ3VtZW50IG11c3QgYmUgYSBub24tbnVsbCBvYmplY3QnKTtcblx0bW9kX2Fzc2VydC5vayhBcnJheS5pc0FycmF5KGFsbG93ZWQpLFxuXHQgICAgJ2FsbG93ZWQgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzJyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYWxsb3dlZC5sZW5ndGg7IGkrKykge1xuXHRcdG1vZF9hc3NlcnQub2sodHlwZW9mIChhbGxvd2VkW2ldKSA9PT0gJ3N0cmluZycsXG5cdFx0ICAgICdhbGxvd2VkIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncycpO1xuXHR9XG5cblx0cmV0dXJuIChPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIChhbGxvd2VkLmluZGV4T2Yoa2V5KSA9PT0gLTEpO1xuXHR9KSk7XG59XG5cbi8qXG4gKiBHaXZlbiB0aHJlZSBzZXRzIG9mIHByb3BlcnRpZXMgXCJwcm92aWRlZFwiIChtYXkgYmUgdW5kZWZpbmVkKSwgXCJvdmVycmlkZXNcIlxuICogKHJlcXVpcmVkKSwgYW5kIFwiZGVmYXVsdHNcIiAobWF5IGJlIHVuZGVmaW5lZCksIGNvbnN0cnVjdCBhbiBvYmplY3QgY29udGFpbmluZ1xuICogdGhlIHVuaW9uIG9mIHRoZXNlIHNldHMgd2l0aCBcIm92ZXJyaWRlc1wiIG92ZXJyaWRpbmcgXCJwcm92aWRlZFwiLCBhbmRcbiAqIFwicHJvdmlkZWRcIiBvdmVycmlkaW5nIFwiZGVmYXVsdHNcIi4gIE5vbmUgb2YgdGhlIGlucHV0IG9iamVjdHMgYXJlIG1vZGlmaWVkLlxuICovXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMocHJvdmlkZWQsIG92ZXJyaWRlcywgZGVmYXVsdHMpXG57XG5cdHZhciBydiwgaztcblxuXHRydiA9IHt9O1xuXHRpZiAoZGVmYXVsdHMpIHtcblx0XHRmb3IgKGsgaW4gZGVmYXVsdHMpXG5cdFx0XHRydltrXSA9IGRlZmF1bHRzW2tdO1xuXHR9XG5cblx0aWYgKHByb3ZpZGVkKSB7XG5cdFx0Zm9yIChrIGluIHByb3ZpZGVkKVxuXHRcdFx0cnZba10gPSBwcm92aWRlZFtrXTtcblx0fVxuXG5cdGlmIChvdmVycmlkZXMpIHtcblx0XHRmb3IgKGsgaW4gb3ZlcnJpZGVzKVxuXHRcdFx0cnZba10gPSBvdmVycmlkZXNba107XG5cdH1cblxuXHRyZXR1cm4gKHJ2KTtcbn1cbiJdLCJuYW1lcyI6WyJtb2RfYXNzZXJ0IiwicmVxdWlyZSIsIm1vZF91dGlsIiwibW9kX2V4dHNwcmludGYiLCJtb2RfdmVycm9yIiwibW9kX2pzb25zY2hlbWEiLCJleHBvcnRzIiwiZGVlcENvcHkiLCJkZWVwRXF1YWwiLCJpc0VtcHR5IiwiaGFzS2V5IiwiZm9yRWFjaEtleSIsInBsdWNrIiwiZmxhdHRlbk9iamVjdCIsImZsYXR0ZW5JdGVyIiwidmFsaWRhdGVKc29uT2JqZWN0IiwidmFsaWRhdGVKc29uT2JqZWN0SlMiLCJyYW5kRWx0IiwiZXh0cmFQcm9wZXJ0aWVzIiwibWVyZ2VPYmplY3RzIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwicGFyc2VJbnRlZ2VyIiwiaXNvODYwMSIsInJmYzExMjMiLCJwYXJzZURhdGVUaW1lIiwiaHJ0aW1lZGlmZiIsImhydGltZURpZmYiLCJocnRpbWVBY2N1bSIsImhydGltZUFkZCIsImhydGltZU5hbm9zZWMiLCJocnRpbWVNaWNyb3NlYyIsImhydGltZU1pbGxpc2VjIiwib2JqIiwicmV0Iiwia2V5IiwibWFya2VyIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsIkFycmF5IiwibGVuZ3RoIiwicHVzaCIsIm9iajEiLCJvYmoyIiwiayIsImhhc093blByb3BlcnR5IiwiZXF1YWwiLCJwcm90b3R5cGUiLCJjYWxsIiwiY2FsbGJhY2siLCJwbHVja3YiLCJ1bmRlZmluZWQiLCJpIiwiaW5kZXhPZiIsImtleTEiLCJzdWJzdHIiLCJkYXRhIiwiZGVwdGgiLCJkb0ZsYXR0ZW5JdGVyIiwiYWNjdW0iLCJlYWNoIiwic2xpY2UiLCJvayIsInJ2IiwiZm9yRWFjaCIsInAiLCJjb25jYXQiLCJzdHIiLCJwcmVmaXgiLCJzdWZmaXgiLCJkIiwiRGF0ZSIsInNwcmludGYiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENNaWxsaXNlY29uZHMiLCJSRkMxMTIzX01PTlRIUyIsIlJGQzExMjNfREFZUyIsImRhdGUiLCJnZXRVVENEYXkiLCJudW1lcmljIiwiaXNOYU4iLCJNQVhfU0FGRV9JTlRFR0VSIiwiTnVtYmVyIiwiTUlOX1NBRkVfSU5URUdFUiIsIlBJX0RFRkFVTFRTIiwiYmFzZSIsImFsbG93U2lnbiIsImFsbG93UHJlZml4IiwiYWxsb3dUcmFpbGluZyIsImFsbG93SW1wcmVjaXNlIiwidHJpbVdoaXRlc3BhY2UiLCJsZWFkaW5nWmVyb0lzT2N0YWwiLCJDUF8wIiwiQ1BfOSIsIkNQX0EiLCJDUF9CIiwiQ1BfTyIsIkNQX1QiLCJDUF9YIiwiQ1BfWiIsIkNQX2EiLCJDUF9iIiwiQ1BfbyIsIkNQX3QiLCJDUF94IiwiQ1BfeiIsIlBJX0NPTlZfREVDIiwiUElfQ09OVl9VQyIsIlBJX0NPTlZfTEMiLCJ1b3B0cyIsInN0cmluZyIsIm9wdGlvbmFsT2JqZWN0IiwiYmFzZU92ZXJyaWRlIiwib3B0aW9ucyIsIm51bWJlciIsImJvb2wiLCJjIiwicGJhc2UiLCJzdGFydCIsIm11bHQiLCJ2YWx1ZSIsImlkeCIsImxlbiIsImlzU3BhY2UiLCJjaGFyQ29kZUF0IiwicHJlZml4VG9CYXNlIiwidHJhbnNsYXRlRGlnaXQiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzdWx0Iiwic2NoZW1hIiwiaW5wdXQiLCJyZXBvcnQiLCJ2YWxpZGF0ZSIsImVycm9ycyIsImVycm9yIiwicHJvcG5hbWUiLCJyZWFzb24iLCJ0b0xvd2VyQ2FzZSIsImoiLCJWRXJyb3IiLCJqc3ZfZGV0YWlscyIsImFyciIsImlzQXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJhc3NlcnRIcnRpbWUiLCJhIiwiYiIsImFsbG93ZWQiLCJrZXlzIiwiZmlsdGVyIiwicHJvdmlkZWQiLCJvdmVycmlkZXMiLCJkZWZhdWx0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/jsprim/lib/jsprim.js\n");

/***/ })

};
;