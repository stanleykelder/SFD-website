/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uri-js";
exports.ids = ["vendor-chunks/uri-js"];
exports.modules = {

/***/ "(action-browser)/./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    function merge() {\n        for(var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++){\n            sets[_key] = arguments[_key];\n        }\n        if (sets.length > 1) {\n            sets[0] = sets[0].slice(0, -1);\n            var xl = sets.length - 1;\n            for(var x = 1; x < xl; ++x){\n                sets[x] = sets[x].slice(1, -1);\n            }\n            sets[xl] = sets[xl].slice(1);\n            return sets.join(\"\");\n        } else {\n            return sets[0];\n        }\n    }\n    function subexp(str) {\n        return \"(?:\" + str + \")\";\n    }\n    function typeOf(o) {\n        return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n    }\n    function toUpperCase(str) {\n        return str.toUpperCase();\n    }\n    function toArray(obj) {\n        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [\n            obj\n        ] : Array.prototype.slice.call(obj) : [];\n    }\n    function assign(target, source) {\n        var obj = target;\n        if (source) {\n            for(var key in source){\n                obj[key] = source[key];\n            }\n        }\n        return obj;\n    }\n    function buildExps(isIRI) {\n        var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), //case-insensitive\n        LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), //expanded\n        GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", //subset, excludes bidi control characters\n        IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", //subset\n        UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$), //relaxed parsing rules\n        IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), //                           6( h16 \":\" ) ls32\n        IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), //                      \"::\" 5( h16 \":\" ) ls32\n        IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n        IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n        IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n        IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$), //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n        IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$), //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n        IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$), //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n        IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"), //[ *6( h16 \":\" ) h16 ] \"::\"\n        IPV6ADDRESS$ = subexp([\n            IPV6ADDRESS1$,\n            IPV6ADDRESS2$,\n            IPV6ADDRESS3$,\n            IPV6ADDRESS4$,\n            IPV6ADDRESS5$,\n            IPV6ADDRESS6$,\n            IPV6ADDRESS7$,\n            IPV6ADDRESS8$,\n            IPV6ADDRESS9$\n        ].join(\"|\")), ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"), //RFC 6874\n        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$), //RFC 6874\n        IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$), //RFC 6874, with relaxed parsing rules\n        IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), //RFC 6874\n        REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), //simplified\n        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), //simplified\n        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), //simplified\n        PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n        return {\n            NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n            NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n            NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n            ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n            UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n            OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n            PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n            IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n            IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n        };\n    }\n    var URI_PROTOCOL = buildExps(false);\n    var IRI_PROTOCOL = buildExps(true);\n    var slicedToArray = function() {\n        function sliceIterator(arr, i) {\n            var _arr = [];\n            var _n = true;\n            var _d = false;\n            var _e = undefined;\n            try {\n                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                    _arr.push(_s.value);\n                    if (i && _arr.length === i) break;\n                }\n            } catch (err) {\n                _d = true;\n                _e = err;\n            } finally{\n                try {\n                    if (!_n && _i[\"return\"]) _i[\"return\"]();\n                } finally{\n                    if (_d) throw _e;\n                }\n            }\n            return _arr;\n        }\n        return function(arr, i) {\n            if (Array.isArray(arr)) {\n                return arr;\n            } else if (Symbol.iterator in Object(arr)) {\n                return sliceIterator(arr, i);\n            } else {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n            }\n        };\n    }();\n    var toConsumableArray = function(arr) {\n        if (Array.isArray(arr)) {\n            for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];\n            return arr2;\n        } else {\n            return Array.from(arr);\n        }\n    };\n    /** Highest positive signed 32-bit float value */ var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n    /** Bootstring parameters */ var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128; // 0x80\n    var delimiter = \"-\"; // '\\x2D'\n    /** Regular expressions */ var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n    /** Error messages */ var errors = {\n        \"overflow\": \"Overflow: input needs wider integers to process\",\n        \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n        \"invalid-input\": \"Invalid input\"\n    };\n    /** Convenience shortcuts */ var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    /*--------------------------------------------------------------------------*/ /**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */ function error$1(type) {\n        throw new RangeError(errors[type]);\n    }\n    /**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */ function map(array, fn) {\n        var result = [];\n        var length = array.length;\n        while(length--){\n            result[length] = fn(array[length]);\n        }\n        return result;\n    }\n    /**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */ function mapDomain(string, fn) {\n        var parts = string.split(\"@\");\n        var result = \"\";\n        if (parts.length > 1) {\n            // In email addresses, only the domain name should be punycoded. Leave\n            // the local part (i.e. everything up to `@`) intact.\n            result = parts[0] + \"@\";\n            string = parts[1];\n        }\n        // Avoid `split(regex)` for IE8 compatibility. See #17.\n        string = string.replace(regexSeparators, \".\");\n        var labels = string.split(\".\");\n        var encoded = map(labels, fn).join(\".\");\n        return result + encoded;\n    }\n    /**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */ function ucs2decode(string) {\n        var output = [];\n        var counter = 0;\n        var length = string.length;\n        while(counter < length){\n            var value = string.charCodeAt(counter++);\n            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // It's a high surrogate, and there is a next character.\n                var extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {\n                    // Low surrogate.\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                    // It's an unmatched surrogate; only append this code unit, in case the\n                    // next code unit is the high surrogate of a surrogate pair.\n                    output.push(value);\n                    counter--;\n                }\n            } else {\n                output.push(value);\n            }\n        }\n        return output;\n    }\n    /**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */ var ucs2encode = function ucs2encode(array) {\n        return String.fromCodePoint.apply(String, toConsumableArray(array));\n    };\n    /**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */ var basicToDigit = function basicToDigit(codePoint) {\n        if (codePoint - 0x30 < 0x0A) {\n            return codePoint - 0x16;\n        }\n        if (codePoint - 0x41 < 0x1A) {\n            return codePoint - 0x41;\n        }\n        if (codePoint - 0x61 < 0x1A) {\n            return codePoint - 0x61;\n        }\n        return base;\n    };\n    /**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */ var digitToBasic = function digitToBasic(digit, flag) {\n        //  0..25 map to ASCII a..z or A..Z\n        // 26..35 map to ASCII 0..9\n        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    /**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */ var adapt = function adapt(delta, numPoints, firstTime) {\n        var k = 0;\n        delta = firstTime ? floor(delta / damp) : delta >> 1;\n        delta += floor(delta / numPoints);\n        for(; delta > baseMinusTMin * tMax >> 1; k += base){\n            delta = floor(delta / baseMinusTMin);\n        }\n        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    /**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */ var decode = function decode(input) {\n        // Don't use UCS-2.\n        var output = [];\n        var inputLength = input.length;\n        var i = 0;\n        var n = initialN;\n        var bias = initialBias;\n        // Handle the basic code points: let `basic` be the number of input code\n        // points before the last delimiter, or `0` if there is none, then copy\n        // the first basic code points to the output.\n        var basic = input.lastIndexOf(delimiter);\n        if (basic < 0) {\n            basic = 0;\n        }\n        for(var j = 0; j < basic; ++j){\n            // if it's not a basic code point\n            if (input.charCodeAt(j) >= 0x80) {\n                error$1(\"not-basic\");\n            }\n            output.push(input.charCodeAt(j));\n        }\n        // Main decoding loop: start just after the last delimiter if any basic code\n        // points were copied; start at the beginning otherwise.\n        for(var index = basic > 0 ? basic + 1 : 0; index < inputLength;)/* no final expression */ {\n            // `index` is the index of the next character to be consumed.\n            // Decode a generalized variable-length integer into `delta`,\n            // which gets added to `i`. The overflow checking is easier\n            // if we increase `i` as we go, then subtract off its starting\n            // value at the end to obtain `delta`.\n            var oldi = i;\n            for(var w = 1, k = base;; k += base){\n                if (index >= inputLength) {\n                    error$1(\"invalid-input\");\n                }\n                var digit = basicToDigit(input.charCodeAt(index++));\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error$1(\"overflow\");\n                }\n                i += digit * w;\n                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (digit < t) {\n                    break;\n                }\n                var baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                    error$1(\"overflow\");\n                }\n                w *= baseMinusT;\n            }\n            var out = output.length + 1;\n            bias = adapt(i - oldi, out, oldi == 0);\n            // `i` was supposed to wrap around from `out` to `0`,\n            // incrementing `n` each time, so we'll fix that now:\n            if (floor(i / out) > maxInt - n) {\n                error$1(\"overflow\");\n            }\n            n += floor(i / out);\n            i %= out;\n            // Insert `n` at position `i` of the output.\n            output.splice(i++, 0, n);\n        }\n        return String.fromCodePoint.apply(String, output);\n    };\n    /**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */ var encode = function encode(input) {\n        var output = [];\n        // Convert the input in UCS-2 to an array of Unicode code points.\n        input = ucs2decode(input);\n        // Cache the length.\n        var inputLength = input.length;\n        // Initialize the state.\n        var n = initialN;\n        var delta = 0;\n        var bias = initialBias;\n        // Handle the basic code points.\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n        try {\n            for(var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _currentValue2 = _step.value;\n                if (_currentValue2 < 0x80) {\n                    output.push(stringFromCharCode(_currentValue2));\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        var basicLength = output.length;\n        var handledCPCount = basicLength;\n        // `handledCPCount` is the number of code points that have been handled;\n        // `basicLength` is the number of basic code points.\n        // Finish the basic string with a delimiter unless it's empty.\n        if (basicLength) {\n            output.push(delimiter);\n        }\n        // Main encoding loop:\n        while(handledCPCount < inputLength){\n            // All non-basic code points < n have been handled already. Find the next\n            // larger one:\n            var m = maxInt;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n            try {\n                for(var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                    var currentValue = _step2.value;\n                    if (currentValue >= n && currentValue < m) {\n                        m = currentValue;\n                    }\n                }\n            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n            // but guard against overflow.\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally{\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n            var handledCPCountPlusOne = handledCPCount + 1;\n            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error$1(\"overflow\");\n            }\n            delta += (m - n) * handledCPCountPlusOne;\n            n = m;\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n            try {\n                for(var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n                    var _currentValue = _step3.value;\n                    if (_currentValue < n && ++delta > maxInt) {\n                        error$1(\"overflow\");\n                    }\n                    if (_currentValue == n) {\n                        // Represent delta as a generalized variable-length integer.\n                        var q = delta;\n                        for(var k = base;; k += base){\n                            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                            if (q < t) {\n                                break;\n                            }\n                            var qMinusT = q - t;\n                            var baseMinusT = base - t;\n                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                            q = floor(qMinusT / baseMinusT);\n                        }\n                        output.push(stringFromCharCode(digitToBasic(q, 0)));\n                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                        delta = 0;\n                        ++handledCPCount;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally{\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n            ++delta;\n            ++n;\n        }\n        return output.join(\"\");\n    };\n    /**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */ var toUnicode = function toUnicode(input) {\n        return mapDomain(input, function(string) {\n            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n        });\n    };\n    /**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */ var toASCII = function toASCII(input) {\n        return mapDomain(input, function(string) {\n            return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n        });\n    };\n    /*--------------------------------------------------------------------------*/ /** Define the public API */ var punycode = {\n        /**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */ \"version\": \"2.1.0\",\n        /**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */ \"ucs2\": {\n            \"decode\": ucs2decode,\n            \"encode\": ucs2encode\n        },\n        \"decode\": decode,\n        \"encode\": encode,\n        \"toASCII\": toASCII,\n        \"toUnicode\": toUnicode\n    };\n    /**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */ /**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */ var SCHEMES = {};\n    function pctEncChar(chr) {\n        var c = chr.charCodeAt(0);\n        var e = void 0;\n        if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();\n        else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();\n        else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n        return e;\n    }\n    function pctDecChars(str) {\n        var newStr = \"\";\n        var i = 0;\n        var il = str.length;\n        while(i < il){\n            var c = parseInt(str.substr(i + 1, 2), 16);\n            if (c < 128) {\n                newStr += String.fromCharCode(c);\n                i += 3;\n            } else if (c >= 194 && c < 224) {\n                if (il - i >= 6) {\n                    var c2 = parseInt(str.substr(i + 4, 2), 16);\n                    newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n                } else {\n                    newStr += str.substr(i, 6);\n                }\n                i += 6;\n            } else if (c >= 224) {\n                if (il - i >= 9) {\n                    var _c = parseInt(str.substr(i + 4, 2), 16);\n                    var c3 = parseInt(str.substr(i + 7, 2), 16);\n                    newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n                } else {\n                    newStr += str.substr(i, 9);\n                }\n                i += 9;\n            } else {\n                newStr += str.substr(i, 3);\n                i += 3;\n            }\n        }\n        return newStr;\n    }\n    function _normalizeComponentEncoding(components, protocol) {\n        function decodeUnreserved(str) {\n            var decStr = pctDecChars(str);\n            return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n        }\n        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n        return components;\n    }\n    function _stripLeadingZeros(str) {\n        return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n    }\n    function _normalizeIPv4(host, protocol) {\n        var matches = host.match(protocol.IPV4ADDRESS) || [];\n        var _matches = slicedToArray(matches, 2), address = _matches[1];\n        if (address) {\n            return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n        } else {\n            return host;\n        }\n    }\n    function _normalizeIPv6(host, protocol) {\n        var matches = host.match(protocol.IPV6ADDRESS) || [];\n        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];\n        if (address) {\n            var _address$toLowerCase$ = address.toLowerCase().split(\"::\").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];\n            var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n            var lastFields = last.split(\":\").map(_stripLeadingZeros);\n            var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n            var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n            var lastFieldsStart = lastFields.length - fieldCount;\n            var fields = Array(fieldCount);\n            for(var x = 0; x < fieldCount; ++x){\n                fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || \"\";\n            }\n            if (isLastFieldIPv4Address) {\n                fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n            }\n            var allZeroFields = fields.reduce(function(acc, field, index) {\n                if (!field || field === \"0\") {\n                    var lastLongest = acc[acc.length - 1];\n                    if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                        lastLongest.length++;\n                    } else {\n                        acc.push({\n                            index: index,\n                            length: 1\n                        });\n                    }\n                }\n                return acc;\n            }, []);\n            var longestZeroFields = allZeroFields.sort(function(a, b) {\n                return b.length - a.length;\n            })[0];\n            var newHost = void 0;\n            if (longestZeroFields && longestZeroFields.length > 1) {\n                var newFirst = fields.slice(0, longestZeroFields.index);\n                var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n                newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n            } else {\n                newHost = fields.join(\":\");\n            }\n            if (zone) {\n                newHost += \"%\" + zone;\n            }\n            return newHost;\n        } else {\n            return host;\n        }\n    }\n    var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n    var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n    function parse(uriString) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var components = {};\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n        var matches = uriString.match(URI_PARSE);\n        if (matches) {\n            if (NO_MATCH_IS_UNDEFINED) {\n                //store each component\n                components.scheme = matches[1];\n                components.userinfo = matches[3];\n                components.host = matches[4];\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = matches[7];\n                components.fragment = matches[8];\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = matches[5];\n                }\n            } else {\n                //IE FIX for improper RegExp matching\n                //store each component\n                components.scheme = matches[1] || undefined;\n                components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n                components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n                components.port = parseInt(matches[5], 10);\n                components.path = matches[6] || \"\";\n                components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n                components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n                //fix port number\n                if (isNaN(components.port)) {\n                    components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n                }\n            }\n            if (components.host) {\n                //normalize IP hosts\n                components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n            }\n            //determine reference type\n            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n                components.reference = \"same-document\";\n            } else if (components.scheme === undefined) {\n                components.reference = \"relative\";\n            } else if (components.fragment === undefined) {\n                components.reference = \"absolute\";\n            } else {\n                components.reference = \"uri\";\n            }\n            //check for reference errors\n            if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n                components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n            }\n            //find scheme handler\n            var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n            //check if scheme can't handle IRIs\n            if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n                //if host component is a domain name\n                if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                    } catch (e) {\n                        components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                }\n                //convert IRI -> URI\n                _normalizeComponentEncoding(components, URI_PROTOCOL);\n            } else {\n                //normalize encodings\n                _normalizeComponentEncoding(components, protocol);\n            }\n            //perform scheme specific parsing\n            if (schemeHandler && schemeHandler.parse) {\n                schemeHandler.parse(components, options);\n            }\n        } else {\n            components.error = components.error || \"URI can not be parsed.\";\n        }\n        return components;\n    }\n    function _recomposeAuthority(components, options) {\n        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        if (components.userinfo !== undefined) {\n            uriTokens.push(components.userinfo);\n            uriTokens.push(\"@\");\n        }\n        if (components.host !== undefined) {\n            //normalize IP hosts, add brackets and escape zone separator for IPv6\n            uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {\n                return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n            }));\n        }\n        if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n            uriTokens.push(\":\");\n            uriTokens.push(String(components.port));\n        }\n        return uriTokens.length ? uriTokens.join(\"\") : undefined;\n    }\n    var RDS1 = /^\\.\\.?\\//;\n    var RDS2 = /^\\/\\.(\\/|$)/;\n    var RDS3 = /^\\/\\.\\.(\\/|$)/;\n    var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n    function removeDotSegments(input) {\n        var output = [];\n        while(input.length){\n            if (input.match(RDS1)) {\n                input = input.replace(RDS1, \"\");\n            } else if (input.match(RDS2)) {\n                input = input.replace(RDS2, \"/\");\n            } else if (input.match(RDS3)) {\n                input = input.replace(RDS3, \"/\");\n                output.pop();\n            } else if (input === \".\" || input === \"..\") {\n                input = \"\";\n            } else {\n                var im = input.match(RDS5);\n                if (im) {\n                    var s = im[0];\n                    input = input.slice(s.length);\n                    output.push(s);\n                } else {\n                    throw new Error(\"Unexpected dot segment condition\");\n                }\n            }\n        }\n        return output.join(\"\");\n    }\n    function serialize(components) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n        var uriTokens = [];\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //perform scheme specific serialization\n        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n        if (components.host) {\n            //if host component is an IPv6 address\n            if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n        }\n        //normalize encoding\n        _normalizeComponentEncoding(components, protocol);\n        if (options.reference !== \"suffix\" && components.scheme) {\n            uriTokens.push(components.scheme);\n            uriTokens.push(\":\");\n        }\n        var authority = _recomposeAuthority(components, options);\n        if (authority !== undefined) {\n            if (options.reference !== \"suffix\") {\n                uriTokens.push(\"//\");\n            }\n            uriTokens.push(authority);\n            if (components.path && components.path.charAt(0) !== \"/\") {\n                uriTokens.push(\"/\");\n            }\n        }\n        if (components.path !== undefined) {\n            var s = components.path;\n            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n                s = removeDotSegments(s);\n            }\n            if (authority === undefined) {\n                s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n            }\n            uriTokens.push(s);\n        }\n        if (components.query !== undefined) {\n            uriTokens.push(\"?\");\n            uriTokens.push(components.query);\n        }\n        if (components.fragment !== undefined) {\n            uriTokens.push(\"#\");\n            uriTokens.push(components.fragment);\n        }\n        return uriTokens.join(\"\"); //merge tokens into a string\n    }\n    function resolveComponents(base, relative) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var skipNormalization = arguments[3];\n        var target = {};\n        if (!skipNormalization) {\n            base = parse(serialize(base, options), options); //normalize base components\n            relative = parse(serialize(relative, options), options); //normalize relative components\n        }\n        options = options || {};\n        if (!options.tolerant && relative.scheme) {\n            target.scheme = relative.scheme;\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n                //target.authority = relative.authority;\n                target.userinfo = relative.userinfo;\n                target.host = relative.host;\n                target.port = relative.port;\n                target.path = removeDotSegments(relative.path || \"\");\n                target.query = relative.query;\n            } else {\n                if (!relative.path) {\n                    target.path = base.path;\n                    if (relative.query !== undefined) {\n                        target.query = relative.query;\n                    } else {\n                        target.query = base.query;\n                    }\n                } else {\n                    if (relative.path.charAt(0) === \"/\") {\n                        target.path = removeDotSegments(relative.path);\n                    } else {\n                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                            target.path = \"/\" + relative.path;\n                        } else if (!base.path) {\n                            target.path = relative.path;\n                        } else {\n                            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                        }\n                        target.path = removeDotSegments(target.path);\n                    }\n                    target.query = relative.query;\n                }\n                //target.authority = base.authority;\n                target.userinfo = base.userinfo;\n                target.host = base.host;\n                target.port = base.port;\n            }\n            target.scheme = base.scheme;\n        }\n        target.fragment = relative.fragment;\n        return target;\n    }\n    function resolve(baseURI, relativeURI, options) {\n        var schemelessOptions = assign({\n            scheme: \"null\"\n        }, options);\n        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n    }\n    function normalize(uri, options) {\n        if (typeof uri === \"string\") {\n            uri = serialize(parse(uri, options), options);\n        } else if (typeOf(uri) === \"object\") {\n            uri = parse(serialize(uri, options), options);\n        }\n        return uri;\n    }\n    function equal(uriA, uriB, options) {\n        if (typeof uriA === \"string\") {\n            uriA = serialize(parse(uriA, options), options);\n        } else if (typeOf(uriA) === \"object\") {\n            uriA = serialize(uriA, options);\n        }\n        if (typeof uriB === \"string\") {\n            uriB = serialize(parse(uriB, options), options);\n        } else if (typeOf(uriB) === \"object\") {\n            uriB = serialize(uriB, options);\n        }\n        return uriA === uriB;\n    }\n    function escapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n    }\n    function unescapeComponent(str, options) {\n        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n    }\n    var handler = {\n        scheme: \"http\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            //report missing host\n            if (!components.host) {\n                components.error = components.error || \"HTTP URIs must have a host.\";\n            }\n            return components;\n        },\n        serialize: function serialize(components, options) {\n            var secure = String(components.scheme).toLowerCase() === \"https\";\n            //normalize the default port\n            if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n                components.port = undefined;\n            }\n            //normalize the empty path\n            if (!components.path) {\n                components.path = \"/\";\n            }\n            //NOTE: We do not parse query strings for HTTP URIs\n            //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n            //and not the HTTP spec.\n            return components;\n        }\n    };\n    var handler$1 = {\n        scheme: \"https\",\n        domainHost: handler.domainHost,\n        parse: handler.parse,\n        serialize: handler.serialize\n    };\n    function isSecure(wsComponents) {\n        return typeof wsComponents.secure === \"boolean\" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n    }\n    //RFC 6455\n    var handler$2 = {\n        scheme: \"ws\",\n        domainHost: true,\n        parse: function parse(components, options) {\n            var wsComponents = components;\n            //indicate if the secure flag is set\n            wsComponents.secure = isSecure(wsComponents);\n            //construct resouce name\n            wsComponents.resourceName = (wsComponents.path || \"/\") + (wsComponents.query ? \"?\" + wsComponents.query : \"\");\n            wsComponents.path = undefined;\n            wsComponents.query = undefined;\n            return wsComponents;\n        },\n        serialize: function serialize(wsComponents, options) {\n            //normalize the default port\n            if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n                wsComponents.port = undefined;\n            }\n            //ensure scheme matches secure flag\n            if (typeof wsComponents.secure === \"boolean\") {\n                wsComponents.scheme = wsComponents.secure ? \"wss\" : \"ws\";\n                wsComponents.secure = undefined;\n            }\n            //reconstruct path from resource name\n            if (wsComponents.resourceName) {\n                var _wsComponents$resourc = wsComponents.resourceName.split(\"?\"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];\n                wsComponents.path = path && path !== \"/\" ? path : undefined;\n                wsComponents.query = query;\n                wsComponents.resourceName = undefined;\n            }\n            //forbid fragment component\n            wsComponents.fragment = undefined;\n            return wsComponents;\n        }\n    };\n    var handler$3 = {\n        scheme: \"wss\",\n        domainHost: handler$2.domainHost,\n        parse: handler$2.parse,\n        serialize: handler$2.serialize\n    };\n    var O = {};\n    var isIRI = true;\n    //RFC 3986\n    var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n    var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n    var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n    //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n    //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n    //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n    //const WSP$$ = \"[\\\\x20\\\\x09]\";\n    //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n    //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n    //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n    //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n    var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n    var VCHAR$$ = merge(QTEXT$$, '[\\\\\"\\\\\\\\]');\n    var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n    var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n    var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n    var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n    var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n    var NOT_HFVALUE = NOT_HFNAME;\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(UNRESERVED) ? str : decStr;\n    }\n    var handler$4 = {\n        scheme: \"mailto\",\n        parse: function parse$$1(components, options) {\n            var mailtoComponents = components;\n            var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n            mailtoComponents.path = undefined;\n            if (mailtoComponents.query) {\n                var unknownHeaders = false;\n                var headers = {};\n                var hfields = mailtoComponents.query.split(\"&\");\n                for(var x = 0, xl = hfields.length; x < xl; ++x){\n                    var hfield = hfields[x].split(\"=\");\n                    switch(hfield[0]){\n                        case \"to\":\n                            var toAddrs = hfield[1].split(\",\");\n                            for(var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x){\n                                to.push(toAddrs[_x]);\n                            }\n                            break;\n                        case \"subject\":\n                            mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                            break;\n                        case \"body\":\n                            mailtoComponents.body = unescapeComponent(hfield[1], options);\n                            break;\n                        default:\n                            unknownHeaders = true;\n                            headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                            break;\n                    }\n                }\n                if (unknownHeaders) mailtoComponents.headers = headers;\n            }\n            mailtoComponents.query = undefined;\n            for(var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2){\n                var addr = to[_x2].split(\"@\");\n                addr[0] = unescapeComponent(addr[0]);\n                if (!options.unicodeSupport) {\n                    //convert Unicode IDN -> ASCII IDN\n                    try {\n                        addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                    } catch (e) {\n                        mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                    }\n                } else {\n                    addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n                }\n                to[_x2] = addr.join(\"@\");\n            }\n            return mailtoComponents;\n        },\n        serialize: function serialize$$1(mailtoComponents, options) {\n            var components = mailtoComponents;\n            var to = toArray(mailtoComponents.to);\n            if (to) {\n                for(var x = 0, xl = to.length; x < xl; ++x){\n                    var toAddr = String(to[x]);\n                    var atIdx = toAddr.lastIndexOf(\"@\");\n                    var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                    var domain = toAddr.slice(atIdx + 1);\n                    //convert IDN via punycode\n                    try {\n                        domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                    } catch (e) {\n                        components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                    }\n                    to[x] = localPart + \"@\" + domain;\n                }\n                components.path = to.join(\",\");\n            }\n            var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n            if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n            if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n            var fields = [];\n            for(var name in headers){\n                if (headers[name] !== O[name]) {\n                    fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n                }\n            }\n            if (fields.length) {\n                components.query = fields.join(\"&\");\n            }\n            return components;\n        }\n    };\n    var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n    //RFC 2141\n    var handler$5 = {\n        scheme: \"urn\",\n        parse: function parse$$1(components, options) {\n            var matches = components.path && components.path.match(URN_PARSE);\n            var urnComponents = components;\n            if (matches) {\n                var scheme = options.scheme || urnComponents.scheme || \"urn\";\n                var nid = matches[1].toLowerCase();\n                var nss = matches[2];\n                var urnScheme = scheme + \":\" + (options.nid || nid);\n                var schemeHandler = SCHEMES[urnScheme];\n                urnComponents.nid = nid;\n                urnComponents.nss = nss;\n                urnComponents.path = undefined;\n                if (schemeHandler) {\n                    urnComponents = schemeHandler.parse(urnComponents, options);\n                }\n            } else {\n                urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n            }\n            return urnComponents;\n        },\n        serialize: function serialize$$1(urnComponents, options) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = urnComponents.nid;\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            if (schemeHandler) {\n                urnComponents = schemeHandler.serialize(urnComponents, options);\n            }\n            var uriComponents = urnComponents;\n            var nss = urnComponents.nss;\n            uriComponents.path = (nid || options.nid) + \":\" + nss;\n            return uriComponents;\n        }\n    };\n    var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n    //RFC 4122\n    var handler$6 = {\n        scheme: \"urn:uuid\",\n        parse: function parse(urnComponents, options) {\n            var uuidComponents = urnComponents;\n            uuidComponents.uuid = uuidComponents.nss;\n            uuidComponents.nss = undefined;\n            if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n                uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n            }\n            return uuidComponents;\n        },\n        serialize: function serialize(uuidComponents, options) {\n            var urnComponents = uuidComponents;\n            //normalize UUID\n            urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n            return urnComponents;\n        }\n    };\n    SCHEMES[handler.scheme] = handler;\n    SCHEMES[handler$1.scheme] = handler$1;\n    SCHEMES[handler$2.scheme] = handler$2;\n    SCHEMES[handler$3.scheme] = handler$3;\n    SCHEMES[handler$4.scheme] = handler$4;\n    SCHEMES[handler$5.scheme] = handler$5;\n    SCHEMES[handler$6.scheme] = handler$6;\n    exports1.SCHEMES = SCHEMES;\n    exports1.pctEncChar = pctEncChar;\n    exports1.pctDecChars = pctDecChars;\n    exports1.parse = parse;\n    exports1.removeDotSegments = removeDotSegments;\n    exports1.serialize = serialize;\n    exports1.resolveComponents = resolveComponents;\n    exports1.resolve = resolve;\n    exports1.normalize = normalize;\n    exports1.equal = equal;\n    exports1.escapeComponent = escapeComponent;\n    exports1.unescapeComponent = unescapeComponent;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=uri.all.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91cmktanMvZGlzdC9lczUvdXJpLmFsbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0RkFBNEYsR0FDM0YsVUFBVUEsTUFBTSxFQUFFQyxPQUFPO0lBQ3pCLEtBQWlELEdBQWNBLFFBQVFDLFdBQ3ZFLENBQ3dDO0FBQ3pDLEdBQUUsSUFBSSxFQUFHLFNBQVVBLFFBQU87SUFBSTtJQUU5QixTQUFTSztRQUNMLElBQUssSUFBSUMsT0FBT0MsVUFBVUMsTUFBTSxFQUFFQyxPQUFPQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7WUFDakZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7UUFDaEM7UUFFQSxJQUFJRixLQUFLRCxNQUFNLEdBQUcsR0FBRztZQUNqQkMsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUM1QixJQUFJQyxLQUFLSixLQUFLRCxNQUFNLEdBQUc7WUFDdkIsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlELElBQUksRUFBRUMsRUFBRztnQkFDekJMLElBQUksQ0FBQ0ssRUFBRSxHQUFHTCxJQUFJLENBQUNLLEVBQUUsQ0FBQ0YsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUNoQztZQUNBSCxJQUFJLENBQUNJLEdBQUcsR0FBR0osSUFBSSxDQUFDSSxHQUFHLENBQUNELEtBQUssQ0FBQztZQUMxQixPQUFPSCxLQUFLTSxJQUFJLENBQUM7UUFDckIsT0FBTztZQUNILE9BQU9OLElBQUksQ0FBQyxFQUFFO1FBQ2xCO0lBQ0o7SUFDQSxTQUFTTyxPQUFPQyxHQUFHO1FBQ2YsT0FBTyxRQUFRQSxNQUFNO0lBQ3pCO0lBQ0EsU0FBU0MsT0FBT0MsQ0FBQztRQUNiLE9BQU9BLE1BQU1DLFlBQVksY0FBY0QsTUFBTSxPQUFPLFNBQVNFLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJ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T0FBTyxDQUFDd0csVUFBVXJGLE1BQU0sQ0FBQyxHQUFHcUY7SUFDNUJ4RyxPQUFPLENBQUMyRyxVQUFVeEYsTUFBTSxDQUFDLEdBQUd3RjtJQUM1QjNHLE9BQU8sQ0FBQytHLFVBQVU1RixNQUFNLENBQUMsR0FBRzRGO0lBQzVCL0csT0FBTyxDQUFDd0gsVUFBVXJHLE1BQU0sQ0FBQyxHQUFHcUc7SUFDNUJ4SCxPQUFPLENBQUMrSSxVQUFVNUgsTUFBTSxDQUFDLEdBQUc0SDtJQUM1Qi9JLE9BQU8sQ0FBQ3NKLFVBQVVuSSxNQUFNLENBQUMsR0FBR21JO0lBRTVCalksU0FBUTJPLE9BQU8sR0FBR0E7SUFDbEIzTyxTQUFRNE8sVUFBVSxHQUFHQTtJQUNyQjVPLFNBQVFnUCxXQUFXLEdBQUdBO0lBQ3RCaFAsU0FBUXFTLEtBQUssR0FBR0E7SUFDaEJyUyxTQUFRMFQsaUJBQWlCLEdBQUdBO0lBQzVCMVQsU0FBUThULFNBQVMsR0FBR0E7SUFDcEI5VCxTQUFRa1UsaUJBQWlCLEdBQUdBO0lBQzVCbFUsU0FBUXNVLE9BQU8sR0FBR0E7SUFDbEJ0VSxTQUFRMFUsU0FBUyxHQUFHQTtJQUNwQjFVLFNBQVE0VSxLQUFLLEdBQUdBO0lBQ2hCNVUsU0FBUStVLGVBQWUsR0FBR0E7SUFDMUIvVSxTQUFRZ1YsaUJBQWlCLEdBQUdBO0lBRTVCM1QsT0FBTytXLGNBQWMsQ0FBQ3BZLFVBQVMsY0FBYztRQUFFcUksT0FBTztJQUFLO0FBRTNELElBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5ub3ZhdGlvbi1jb2FjaC8uL25vZGVfbW9kdWxlcy91cmktanMvZGlzdC9lczUvdXJpLmFsbC5qcz9lN2ZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBVUkkuanMgdjQuNC4xIChjKSAyMDExIEdhcnkgQ291cnQuIExpY2Vuc2U6IGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanMgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5VUkkgPSBnbG9iYWwuVVJJIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIHggPSAxOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgc2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBzZXRzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXRzWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YmV4cChzdHIpIHtcbiAgICByZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IG8gPT09IG51bGwgPyBcIm51bGxcIiA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zcGxpdChcIiBcIikucG9wKCkuc3BsaXQoXCJdXCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogdHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSA6IFtdO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIG9iaiA9IHRhcmdldDtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJKSB7XG4gICAgdmFyIEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG4gICAgICAgIENSJCA9IFwiW1xcXFx4MERdXCIsXG4gICAgICAgIERJR0lUJCQgPSBcIlswLTldXCIsXG4gICAgICAgIERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcbiAgICAgICAgSEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLFxuICAgICAgICAvL2Nhc2UtaW5zZW5zaXRpdmVcbiAgICBMRiQkID0gXCJbXFxcXHgwQV1cIixcbiAgICAgICAgU1AkJCA9IFwiW1xcXFx4MjBdXCIsXG4gICAgICAgIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSxcbiAgICAgICAgLy9leHBhbmRlZFxuICAgIEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuICAgICAgICBTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuICAgICAgICBSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuICAgICAgICBVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgSVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXRcbiAgICBVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcbiAgICAgICAgU0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcbiAgICAgICAgVVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuICAgICAgICBERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcbiAgICAgICAgREVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSxcbiAgICAgICAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcbiAgICAgICAgSDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG4gICAgICAgIExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG4gICAgICAgIElQVjZBRERSRVNTMSQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MyJCA9IHN1YmV4cChcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCArIFwiXFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgIElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgIElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCksXG4gICAgICAgIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICBJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiksXG4gICAgICAgIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgSVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG4gICAgICAgIFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuICAgICAgICBJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuICAgICAgICBIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuICAgICAgICBQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuICAgICAgICBBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcbiAgICAgICAgUENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcbiAgICAgICAgU0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuICAgICAgICBTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG4gICAgICAgIFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuICAgICAgICBQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG4gICAgICAgIFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcbiAgICAgICAgUEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuICAgICAgICBGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcbiAgICAgICAgSElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG4gICAgICAgIEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcbiAgICAgICAgR0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgU0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBOT1RfU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1VTRVJJTkZPOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0hPU1Q6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEg6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEhfTk9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9RVUVSWTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0ZSQUdNRU5UOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuICAgICAgICBFU0NBUEU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIFVOUkVTRVJWRUQ6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG4gICAgICAgIE9USEVSX0NIQVJTOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuICAgICAgICBQQ1RfRU5DT0RFRDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcbiAgICAgICAgSVBWNEFERFJFU1M6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcbiAgICAgICAgSVBWNkFERFJFU1M6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgfTtcbn1cbnZhciBVUklfUFJPVE9DT0wgPSBidWlsZEV4cHMoZmFsc2UpO1xuXG52YXIgSVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKHRydWUpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xudmFyIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx4N0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbnZhciBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IkMSh0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbnZhciB1Y3MyZW5jb2RlID0gZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCB0b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG52YXIgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0dmFyIGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoOyAvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdC8vIERvbid0IHVzZSBVQ1MtMi5cblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBpID0gMDtcblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0dmFyIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAodmFyIGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yJDEoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKHZhciBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7KSAvKiBubyBmaW5hbCBleHByZXNzaW9uICove1xuXG5cdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHR2YXIgb2xkaSA9IGk7XG5cdFx0Zm9yICh2YXIgdyA9IDEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvciQxKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblx0XHR9XG5cblx0XHR2YXIgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCBvdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGRlbHRhID0gMDtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdHZhciBfY3VycmVudFZhbHVlMiA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZTIgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShfY3VycmVudFZhbHVlMikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHR2YXIgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHR2YXIgbSA9IG1heEludDtcblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0dmFyIF9jdXJyZW50VmFsdWUgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0XHR2YXIgcSA9IGRlbHRhO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbnZhciB0b1VuaWNvZGUgPSBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xudmFyIHRvQVNDSUkgPSBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xudmFyIHB1bnljb2RlID0ge1xuXHQvKipcbiAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgU3RyaW5nXG4gICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG4gICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcbiAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIE9iamVjdFxuICAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTEgR2FyeSBDb3VydC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcbiAqIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiAgICAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqICAgICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBHQVJZIENPVVJUIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdBUlkgQ09VUlQgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbiAqIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXG4gKiBhdXRob3JzIGFuZCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIHJlcHJlc2VudGluZyBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZFxuICogb3IgaW1wbGllZCwgb2YgR2FyeSBDb3VydC5cbiAqL1xudmFyIFNDSEVNRVMgPSB7fTtcbmZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyKSB7XG4gICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZSA9IHZvaWQgMDtcbiAgICBpZiAoYyA8IDE2KSBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoYyA+PiA2IHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBlID0gXCIlXCIgKyAoYyA+PiAxMiB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjID4+IDYgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyKSB7XG4gICAgdmFyIG5ld1N0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbCA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBpbCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gOSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChfYyAmIDYzKSA8PCA2IHwgYzMgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgMyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0cjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xuICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgICAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lKSBjb21wb25lbnRzLnNjaGVtZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9TQ0hFTUUsIFwiXCIpO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5wYXRoID0gU3RyaW5nKGNvbXBvbmVudHMucGF0aCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnF1ZXJ5ID0gU3RyaW5nKGNvbXBvbmVudHMucXVlcnkpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1FVRVJZLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlcyA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMiksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlc1sxXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnNwbGl0KFwiLlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKS5qb2luKFwiLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2Nihob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMyID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAzKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzMlsxXSxcbiAgICAgICAgem9uZSA9IF9tYXRjaGVzMlsyXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgX2FkZHJlc3MkdG9Mb3dlckNhc2UkMiA9IHNsaWNlZFRvQXJyYXkoX2FkZHJlc3MkdG9Mb3dlckNhc2UkLCAyKSxcbiAgICAgICAgICAgIGxhc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzBdLFxuICAgICAgICAgICAgZmlyc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzFdO1xuXG4gICAgICAgIHZhciBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG4gICAgICAgIHZhciBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG4gICAgICAgIHZhciBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcbiAgICAgICAgdmFyIGZpZWxkcyA9IEFycmF5KGZpZWxkQ291bnQpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuICAgICAgICAgICAgZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMb25nZXN0ICYmIGxhc3RMb25nZXN0LmluZGV4ICsgbGFzdExvbmdlc3QubGVuZ3RoID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TG9uZ2VzdC5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaCh7IGluZGV4OiBpbmRleCwgbGVuZ3RoOiAxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBuZXdIb3N0ID0gdm9pZCAwO1xuICAgICAgICBpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KTtcbiAgICAgICAgICAgIHZhciBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIb3N0ID0gZmllbGRzLmpvaW4oXCI6XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b25lKSB7XG4gICAgICAgICAgICBuZXdIb3N0ICs9IFwiJVwiICsgem9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG52YXIgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG52YXIgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gXCJcIi5tYXRjaCgvKCl7MH0vKVsxXSA9PT0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG4gICAgdmFyIG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gdXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSB1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gdXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0c1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuICAgICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGlzIG5vdCBhIFwiICsgb3B0aW9ucy5yZWZlcmVuY2UgKyBcIiByZWZlcmVuY2UuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb252ZXJ0IElSSSAtPiBVUklcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgZW5jb2RpbmdzXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICAgICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiQFwiKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzLCBhZGQgYnJhY2tldHMgYW5kIGVzY2FwZSB6b25lIHNlcGFyYXRvciBmb3IgSVB2NlxuICAgICAgICB1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50cy5wb3J0KSk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBSRFMxID0gL15cXC5cXC4/XFwvLztcbnZhciBSRFMyID0gL15cXC9cXC4oXFwvfCQpLztcbnZhciBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbnZhciBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsIFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG4gICAgICAgICAgICBpZiAoaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGltWzBdO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhbiBJUHY2IGFkZHJlc3NcbiAgICAgICAgaWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge31cbiAgICAgICAgLy9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ1xuICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgIH1cbiAgICB2YXIgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBjb21wb25lbnRzLnBhdGg7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7IC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChzKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIj9cIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMuam9pbihcIlwiKTsgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyhiYXNlLCByZWxhdGl2ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgc2tpcE5vcm1hbGl6YXRpb24gPSBhcmd1bWVudHNbM107XG5cbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgICAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG4gICAgICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgICAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICB9XG4gICAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICAgIHZhciBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSksIHNjaGVtZWxlc3NPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHVyaSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaTtcbn1cblxuZnVuY3Rpb24gZXF1YWwodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHVyaUEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZSh1cmlCLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaUEgPT09IHVyaUI7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUsIHBjdEVuY0NoYXIpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVELCBwY3REZWNDaGFycyk7XG59XG5cbnZhciBoYW5kbGVyID0ge1xuICAgIHNjaGVtZTogXCJodHRwXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL3JlcG9ydCBtaXNzaW5nIGhvc3RcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09IFwiaHR0cHNcIjtcbiAgICAgICAgLy9ub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICAgICAgICBpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gICAgICAgIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgICAgICAgLy9hcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgICAgICAgLy9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDEgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlci5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlci5zZXJpYWxpemVcbn07XG5cbmZ1bmN0aW9uIGlzU2VjdXJlKHdzQ29tcG9uZW50cykge1xuICAgIHJldHVybiB0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nID8gd3NDb21wb25lbnRzLnNlY3VyZSA6IFN0cmluZyh3c0NvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcIndzc1wiO1xufVxuLy9SRkMgNjQ1NVxudmFyIGhhbmRsZXIkMiA9IHtcbiAgICBzY2hlbWU6IFwid3NcIixcbiAgICBkb21haW5Ib3N0OiB0cnVlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3c0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICAvL2luZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IGlzU2VjdXJlKHdzQ29tcG9uZW50cyk7XG4gICAgICAgIC8vY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICAgICAgICB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50cy5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnRzLnF1ZXJ5IDogJycpO1xuICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3NDb21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUod3NDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9lbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgICAgICAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zY2hlbWUgPSB3c0NvbXBvbmVudHMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL3JlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3dzQ29tcG9uZW50cyRyZXNvdXJjID0gd3NDb21wb25lbnRzLnJlc291cmNlTmFtZS5zcGxpdCgnPycpLFxuICAgICAgICAgICAgICAgIF93c0NvbXBvbmVudHMkcmVzb3VyYzIgPSBzbGljZWRUb0FycmF5KF93c0NvbXBvbmVudHMkcmVzb3VyYywgMiksXG4gICAgICAgICAgICAgICAgcGF0aCA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMF0sXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzFdO1xuXG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL2ZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgICAgICAgd3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDMgPSB7XG4gICAgc2NoZW1lOiBcIndzc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIkMi5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyJDIucGFyc2UsXG4gICAgc2VyaWFsaXplOiBoYW5kbGVyJDIuc2VyaWFsaXplXG59O1xuXG52YXIgTyA9IHt9O1xudmFyIGlzSVJJID0gdHJ1ZTtcbi8vUkZDIDM5ODZcbnZhciBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG52YXIgSEVYRElHJCQgPSBcIlswLTlBLUZhLWZdXCI7IC8vY2FzZS1pbnNlbnNpdGl2ZVxudmFyIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKTsgLy9leHBhbmRlZFxuLy9SRkMgNTMyMiwgZXhjZXB0IHRoZXNlIHN5bWJvbHMgYXMgcGVyIFJGQyA2MDY4OiBAIDogLyA/ICMgWyBdICYgOyA9XG4vL2NvbnN0IEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcL1xcXFw9XFxcXD9cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FURVhUJCQgPSBcIltcXFxceDAxLVxcXFx4MDhcXFxceDBCXFxcXHgwQ1xcXFx4MEUtXFxcXHgxRlxcXFx4N0ZdXCI7ICAvLyglZDEtOCAvICVkMTEtMTIgLyAlZDE0LTMxIC8gJWQxMjcpXG4vL2NvbnN0IFFURVhUJCQgPSBtZXJnZShcIltcXFxceDIxXFxcXHgyMy1cXFxceDVCXFxcXHg1RC1cXFxceDdFXVwiLCBPQlNfUVRFWFQkJCk7ICAvLyVkMzMgLyAlZDM1LTkxIC8gJWQ5My0xMjYgLyBvYnMtcXRleHRcbi8vY29uc3QgVkNIQVIkJCA9IFwiW1xcXFx4MjEtXFxcXHg3RV1cIjtcbi8vY29uc3QgV1NQJCQgPSBcIltcXFxceDIwXFxcXHgwOV1cIjtcbi8vY29uc3QgT0JTX1FQJCA9IHN1YmV4cChcIlxcXFxcXFxcXCIgKyBtZXJnZShcIltcXFxceDAwXFxcXHgwRFxcXFx4MEFdXCIsIE9CU19RVEVYVCQkKSk7ICAvLyVkMCAvIENSIC8gTEYgLyBvYnMtcXRleHRcbi8vY29uc3QgRldTJCA9IHN1YmV4cChzdWJleHAoV1NQJCQgKyBcIipcIiArIFwiXFxcXHgwRFxcXFx4MEFcIikgKyBcIj9cIiArIFdTUCQkICsgXCIrXCIpO1xuLy9jb25zdCBRVU9URURfUEFJUiQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXFxcXFxcIiArIHN1YmV4cChWQ0hBUiQkICsgXCJ8XCIgKyBXU1AkJCkpICsgXCJ8XCIgKyBPQlNfUVAkKTtcbi8vY29uc3QgUVVPVEVEX1NUUklORyQgPSBzdWJleHAoJ1xcXFxcIicgKyBzdWJleHAoRldTJCArIFwiP1wiICsgUUNPTlRFTlQkKSArIFwiKlwiICsgRldTJCArIFwiP1wiICsgJ1xcXFxcIicpO1xudmFyIEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xudmFyIFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbnZhciBWQ0hBUiQkID0gbWVyZ2UoUVRFWFQkJCwgXCJbXFxcXFxcXCJcXFxcXFxcXF1cIik7XG52YXIgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG52YXIgVU5SRVNFUlZFRCA9IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIik7XG52YXIgUENUX0VOQ09ERUQgPSBuZXcgUmVnRXhwKFBDVF9FTkNPREVEJCwgXCJnXCIpO1xudmFyIE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZOQU1FID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBVTlJFU0VSVkVEJCQsIFNPTUVfREVMSU1TJCQpLCBcImdcIik7XG52YXIgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHIpIHtcbiAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChVTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbn1cbnZhciBoYW5kbGVyJDQgPSB7XG4gICAgc2NoZW1lOiBcIm1haWx0b1wiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYWlsdG9Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gbWFpbHRvQ29tcG9uZW50cy50byA9IG1haWx0b0NvbXBvbmVudHMucGF0aCA/IG1haWx0b0NvbXBvbmVudHMucGF0aC5zcGxpdChcIixcIikgOiBbXTtcbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuICAgICAgICAgICAgdmFyIHVua25vd25IZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgdmFyIGhmaWVsZHMgPSBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IGhmaWVsZHMubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciBoZmllbGQgPSBoZmllbGRzW3hdLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGhmaWVsZFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0FkZHJzID0gaGZpZWxkWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF94ID0gMCwgX3hsID0gdG9BZGRycy5sZW5ndGg7IF94IDwgX3hsOyArK194KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8ucHVzaCh0b0FkZHJzW194XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN1YmplY3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuYm9keSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVua25vd25IZWFkZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAodmFyIF94MiA9IDAsIF94bDIgPSB0by5sZW5ndGg7IF94MiA8IF94bDI7ICsrX3gyKSB7XG4gICAgICAgICAgICB2YXIgYWRkciA9IHRvW194Ml0uc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgYWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJbMV0gPSBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5lcnJvciA9IG1haWx0b0NvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyWzFdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvW194Ml0gPSBhZGRyLmpvaW4oXCJAXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWlsdG9Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEobWFpbHRvQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1haWx0b0NvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IHRvQXJyYXkobWFpbHRvQ29tcG9uZW50cy50byk7XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgICAgIHZhciB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuICAgICAgICAgICAgICAgIHZhciBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUGFydCA9IHRvQWRkci5zbGljZSgwLCBhdElkeCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoZG9tYWluLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShkb21haW4pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJFbWFpbCBhZGRyZXNzJ3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSB0by5qb2luKFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCkgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLmJvZHkpIGhlYWRlcnNbXCJib2R5XCJdID0gbWFpbHRvQ29tcG9uZW50cy5ib2R5O1xuICAgICAgICB2YXIgZmllbGRzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICsgXCI9XCIgKyBoZWFkZXJzW25hbWVdLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRlZBTFVFLCBwY3RFbmNDaGFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG4vL1JGQyAyMTQxXG52YXIgaGFuZGxlciQ1ID0ge1xuICAgIHNjaGVtZTogXCJ1cm5cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGgubWF0Y2goVVJOX1BBUlNFKTtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgICAgICB2YXIgbmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5zcyA9IG1hdGNoZXNbMl07XG4gICAgICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uaWQgPSBuaWQ7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgIHZhciBuaWQgPSB1cm5Db21wb25lbnRzLm5pZDtcbiAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmlDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdmFyIG5zcyA9IHVybkNvbXBvbmVudHMubnNzO1xuICAgICAgICB1cmlDb21wb25lbnRzLnBhdGggPSAobmlkIHx8IG9wdGlvbnMubmlkKSArIFwiOlwiICsgbnNzO1xuICAgICAgICByZXR1cm4gdXJpQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVVJRCA9IC9eWzAtOUEtRmEtZl17OH0oPzpcXC1bMC05QS1GYS1mXXs0fSl7M31cXC1bMC05QS1GYS1mXXsxMn0kLztcbi8vUkZDIDQxMjJcbnZhciBoYW5kbGVyJDYgPSB7XG4gICAgc2NoZW1lOiBcInVybjp1dWlkXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcbiAgICAgICAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuICAgICAgICAgICAgdXVpZENvbXBvbmVudHMuZXJyb3IgPSB1dWlkQ29tcG9uZW50cy5lcnJvciB8fCBcIlVVSUQgaXMgbm90IHZhbGlkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dWlkQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHV1aWRDb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHM7XG4gICAgICAgIC8vbm9ybWFsaXplIFVVSURcbiAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG5TQ0hFTUVTW2hhbmRsZXIuc2NoZW1lXSA9IGhhbmRsZXI7XG5TQ0hFTUVTW2hhbmRsZXIkMS5zY2hlbWVdID0gaGFuZGxlciQxO1xuU0NIRU1FU1toYW5kbGVyJDIuc2NoZW1lXSA9IGhhbmRsZXIkMjtcblNDSEVNRVNbaGFuZGxlciQzLnNjaGVtZV0gPSBoYW5kbGVyJDM7XG5TQ0hFTUVTW2hhbmRsZXIkNC5zY2hlbWVdID0gaGFuZGxlciQ0O1xuU0NIRU1FU1toYW5kbGVyJDUuc2NoZW1lXSA9IGhhbmRsZXIkNTtcblNDSEVNRVNbaGFuZGxlciQ2LnNjaGVtZV0gPSBoYW5kbGVyJDY7XG5cbmV4cG9ydHMuU0NIRU1FUyA9IFNDSEVNRVM7XG5leHBvcnRzLnBjdEVuY0NoYXIgPSBwY3RFbmNDaGFyO1xuZXhwb3J0cy5wY3REZWNDaGFycyA9IHBjdERlY0NoYXJzO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnJlc29sdmVDb21wb25lbnRzID0gcmVzb2x2ZUNvbXBvbmVudHM7XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG5leHBvcnRzLmVzY2FwZUNvbXBvbmVudCA9IGVzY2FwZUNvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVDb21wb25lbnQgPSB1bmVzY2FwZUNvbXBvbmVudDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5hbGwuanMubWFwXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJVUkkiLCJtZXJnZSIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZXRzIiwiQXJyYXkiLCJfa2V5Iiwic2xpY2UiLCJ4bCIsIngiLCJqb2luIiwic3ViZXhwIiwic3RyIiwidHlwZU9mIiwibyIsInVuZGVmaW5lZCIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNwbGl0IiwicG9wIiwic2hpZnQiLCJ0b0xvd2VyQ2FzZSIsInRvVXBwZXJDYXNlIiwidG9BcnJheSIsIm9iaiIsInNldEludGVydmFsIiwiYXNzaWduIiwidGFyZ2V0Iiwic291cmNlIiwia2V5IiwiYnVpbGRFeHBzIiwiaXNJUkkiLCJBTFBIQSQkIiwiQ1IkIiwiRElHSVQkJCIsIkRRVU9URSQkIiwiSEVYRElHJCQiLCJMRiQkIiwiU1AkJCIsIlBDVF9FTkNPREVEJCIsIkdFTl9ERUxJTVMkJCIsIlNVQl9ERUxJTVMkJCIsIlJFU0VSVkVEJCQiLCJVQ1NDSEFSJCQiLCJJUFJJVkFURSQkIiwiVU5SRVNFUlZFRCQkIiwiU0NIRU1FJCIsIlVTRVJJTkZPJCIsIkRFQ19PQ1RFVCQiLCJERUNfT0NURVRfUkVMQVhFRCQiLCJJUFY0QUREUkVTUyQiLCJIMTYkIiwiTFMzMiQiLCJJUFY2QUREUkVTUzEkIiwiSVBWNkFERFJFU1MyJCIsIklQVjZBRERSRVNTMyQiLCJJUFY2QUREUkVTUzQkIiwiSVBWNkFERFJFU1M1JCIsIklQVjZBRERSRVNTNiQiLCJJUFY2QUREUkVTUzckIiwiSVBWNkFERFJFU1M4JCIsIklQVjZBRERSRVNTOSQiLCJJUFY2QUREUkVTUyQiLCJaT05FSUQkIiwiSVBWNkFERFJaJCIsIklQVjZBRERSWl9SRUxBWEVEJCIsIklQVkZVVFVSRSQiLCJJUF9MSVRFUkFMJCIsIlJFR19OQU1FJCIsIkhPU1QkIiwiUE9SVCQiLCJBVVRIT1JJVFkkIiwiUENIQVIkIiwiU0VHTUVOVCQiLCJTRUdNRU5UX05aJCIsIlNFR01FTlRfTlpfTkMkIiwiUEFUSF9BQkVNUFRZJCIsIlBBVEhfQUJTT0xVVEUkIiwiUEFUSF9OT1NDSEVNRSQiLCJQQVRIX1JPT1RMRVNTJCIsIlBBVEhfRU1QVFkkIiwiUEFUSCQiLCJRVUVSWSQiLCJGUkFHTUVOVCQiLCJISUVSX1BBUlQkIiwiVVJJJCIsIlJFTEFUSVZFX1BBUlQkIiwiUkVMQVRJVkUkIiwiVVJJX1JFRkVSRU5DRSQiLCJBQlNPTFVURV9VUkkkIiwiR0VORVJJQ19SRUYkIiwiUkVMQVRJVkVfUkVGJCIsIkFCU09MVVRFX1JFRiQiLCJTQU1FRE9DX1JFRiQiLCJBVVRIT1JJVFlfUkVGJCIsIk5PVF9TQ0hFTUUiLCJSZWdFeHAiLCJOT1RfVVNFUklORk8iLCJOT1RfSE9TVCIsIk5PVF9QQVRIIiwiTk9UX1BBVEhfTk9TQ0hFTUUiLCJOT1RfUVVFUlkiLCJOT1RfRlJBR01FTlQiLCJFU0NBUEUiLCJVTlJFU0VSVkVEIiwiT1RIRVJfQ0hBUlMiLCJQQ1RfRU5DT0RFRCIsIklQVjRBRERSRVNTIiwiSVBWNkFERFJFU1MiLCJVUklfUFJPVE9DT0wiLCJJUklfUFJPVE9DT0wiLCJzbGljZWRUb0FycmF5Iiwic2xpY2VJdGVyYXRvciIsImFyciIsImkiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl9zIiwibmV4dCIsImRvbmUiLCJwdXNoIiwidmFsdWUiLCJlcnIiLCJpc0FycmF5IiwiVHlwZUVycm9yIiwidG9Db25zdW1hYmxlQXJyYXkiLCJhcnIyIiwiZnJvbSIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsImRlbGltaXRlciIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsImZsb29yIiwiTWF0aCIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImVycm9yJDEiLCJ0eXBlIiwiUmFuZ2VFcnJvciIsIm1hcCIsImFycmF5IiwiZm4iLCJyZXN1bHQiLCJtYXBEb21haW4iLCJzdHJpbmciLCJwYXJ0cyIsInJlcGxhY2UiLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsIm91dHB1dCIsImNvdW50ZXIiLCJjaGFyQ29kZUF0IiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiZnJvbUNvZGVQb2ludCIsImFwcGx5IiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImsiLCJkZWNvZGUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwibiIsImJpYXMiLCJiYXNpYyIsImxhc3RJbmRleE9mIiwiaiIsImluZGV4Iiwib2xkaSIsInciLCJ0IiwiYmFzZU1pbnVzVCIsIm91dCIsInNwbGljZSIsImVuY29kZSIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24iLCJfZGlkSXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJfY3VycmVudFZhbHVlMiIsInJldHVybiIsImJhc2ljTGVuZ3RoIiwiaGFuZGxlZENQQ291bnQiLCJtIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIiLCJfZGlkSXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3JFcnJvcjIiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMiLCJfZGlkSXRlcmF0b3JFcnJvcjMiLCJfaXRlcmF0b3JFcnJvcjMiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiX2N1cnJlbnRWYWx1ZSIsInEiLCJxTWludXNUIiwidG9Vbmljb2RlIiwidGVzdCIsInRvQVNDSUkiLCJwdW55Y29kZSIsIlNDSEVNRVMiLCJwY3RFbmNDaGFyIiwiY2hyIiwiYyIsImUiLCJwY3REZWNDaGFycyIsIm5ld1N0ciIsImlsIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJjMiIsIl9jIiwiYzMiLCJfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmciLCJjb21wb25lbnRzIiwicHJvdG9jb2wiLCJkZWNvZGVVbnJlc2VydmVkIiwiZGVjU3RyIiwibWF0Y2giLCJzY2hlbWUiLCJ1c2VyaW5mbyIsImhvc3QiLCJwYXRoIiwicXVlcnkiLCJmcmFnbWVudCIsIl9zdHJpcExlYWRpbmdaZXJvcyIsIl9ub3JtYWxpemVJUHY0IiwibWF0Y2hlcyIsIl9tYXRjaGVzIiwiYWRkcmVzcyIsIl9ub3JtYWxpemVJUHY2IiwiX21hdGNoZXMyIiwiem9uZSIsIl9hZGRyZXNzJHRvTG93ZXJDYXNlJCIsInJldmVyc2UiLCJfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyIiwibGFzdCIsImZpcnN0IiwiZmlyc3RGaWVsZHMiLCJsYXN0RmllbGRzIiwiaXNMYXN0RmllbGRJUHY0QWRkcmVzcyIsImZpZWxkQ291bnQiLCJsYXN0RmllbGRzU3RhcnQiLCJmaWVsZHMiLCJhbGxaZXJvRmllbGRzIiwicmVkdWNlIiwiYWNjIiwiZmllbGQiLCJsYXN0TG9uZ2VzdCIsImxvbmdlc3RaZXJvRmllbGRzIiwic29ydCIsImEiLCJiIiwibmV3SG9zdCIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsIlVSSV9QQVJTRSIsIk5PX01BVENIX0lTX1VOREVGSU5FRCIsInBhcnNlIiwidXJpU3RyaW5nIiwib3B0aW9ucyIsImlyaSIsInJlZmVyZW5jZSIsInBvcnQiLCJpc05hTiIsImluZGV4T2YiLCJlcnJvciIsInNjaGVtZUhhbmRsZXIiLCJ1bmljb2RlU3VwcG9ydCIsImRvbWFpbkhvc3QiLCJfcmVjb21wb3NlQXV0aG9yaXR5IiwidXJpVG9rZW5zIiwiXyIsIiQxIiwiJDIiLCJSRFMxIiwiUkRTMiIsIlJEUzMiLCJSRFM1IiwicmVtb3ZlRG90U2VnbWVudHMiLCJpbSIsInMiLCJFcnJvciIsInNlcmlhbGl6ZSIsImF1dGhvcml0eSIsImNoYXJBdCIsImFic29sdXRlUGF0aCIsInJlc29sdmVDb21wb25lbnRzIiwicmVsYXRpdmUiLCJza2lwTm9ybWFsaXphdGlvbiIsInRvbGVyYW50IiwicmVzb2x2ZSIsImJhc2VVUkkiLCJyZWxhdGl2ZVVSSSIsInNjaGVtZWxlc3NPcHRpb25zIiwibm9ybWFsaXplIiwidXJpIiwiZXF1YWwiLCJ1cmlBIiwidXJpQiIsImVzY2FwZUNvbXBvbmVudCIsInVuZXNjYXBlQ29tcG9uZW50IiwiaGFuZGxlciIsInNlY3VyZSIsImhhbmRsZXIkMSIsImlzU2VjdXJlIiwid3NDb21wb25lbnRzIiwiaGFuZGxlciQyIiwicmVzb3VyY2VOYW1lIiwiX3dzQ29tcG9uZW50cyRyZXNvdXJjIiwiX3dzQ29tcG9uZW50cyRyZXNvdXJjMiIsImhhbmRsZXIkMyIsIk8iLCJBVEVYVCQkIiwiUVRFWFQkJCIsIlZDSEFSJCQiLCJTT01FX0RFTElNUyQkIiwiTk9UX0xPQ0FMX1BBUlQiLCJOT1RfSEZOQU1FIiwiTk9UX0hGVkFMVUUiLCJoYW5kbGVyJDQiLCJwYXJzZSQkMSIsIm1haWx0b0NvbXBvbmVudHMiLCJ0byIsInVua25vd25IZWFkZXJzIiwiaGVhZGVycyIsImhmaWVsZHMiLCJoZmllbGQiLCJ0b0FkZHJzIiwiX3giLCJfeGwiLCJzdWJqZWN0IiwiYm9keSIsIl94MiIsIl94bDIiLCJhZGRyIiwic2VyaWFsaXplJCQxIiwidG9BZGRyIiwiYXRJZHgiLCJsb2NhbFBhcnQiLCJkb21haW4iLCJuYW1lIiwiVVJOX1BBUlNFIiwiaGFuZGxlciQ1IiwidXJuQ29tcG9uZW50cyIsIm5pZCIsIm5zcyIsInVyblNjaGVtZSIsInVyaUNvbXBvbmVudHMiLCJVVUlEIiwiaGFuZGxlciQ2IiwidXVpZENvbXBvbmVudHMiLCJ1dWlkIiwiZGVmaW5lUHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/uri-js/dist/es5/uri.all.js\n");

/***/ })

};
;