"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/verror";
exports.ids = ["vendor-chunks/verror"];
exports.modules = {

/***/ "(action-browser)/./node_modules/verror/lib/verror.js":
/*!*******************************************!*\
  !*** ./node_modules/verror/lib/verror.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * verror.js: richer JavaScript errors\n */ \nvar mod_assertplus = __webpack_require__(/*! assert-plus */ \"(action-browser)/./node_modules/assert-plus/assert.js\");\nvar mod_util = __webpack_require__(/*! util */ \"util\");\nvar mod_extsprintf = __webpack_require__(/*! extsprintf */ \"(action-browser)/./node_modules/extsprintf/lib/extsprintf.js\");\nvar mod_isError = (__webpack_require__(/*! core-util-is */ \"(action-browser)/./node_modules/core-util-is/lib/util.js\").isError);\nvar sprintf = mod_extsprintf.sprintf;\n/*\n * Public interface\n */ /* So you can 'var VError = require('verror')' */ module.exports = VError;\n/* For compatibility */ VError.VError = VError;\n/* Other exported classes */ VError.SError = SError;\nVError.WError = WError;\nVError.MultiError = MultiError;\n/*\n * Common function used to parse constructor arguments for VError, WError, and\n * SError.  Named arguments to this function:\n *\n *     strict\t\tforce strict interpretation of sprintf arguments, even\n *     \t\t\tif the options in \"argv\" don't say so\n *\n *     argv\t\terror's constructor arguments, which are to be\n *     \t\t\tinterpreted as described in README.md.  For quick\n *     \t\t\treference, \"argv\" has one of the following forms:\n *\n *          [ sprintf_args... ]           (argv[0] is a string)\n *          [ cause, sprintf_args... ]    (argv[0] is an Error)\n *          [ options, sprintf_args... ]  (argv[0] is an object)\n *\n * This function normalizes these forms, producing an object with the following\n * properties:\n *\n *    options           equivalent to \"options\" in third form.  This will never\n *    \t\t\tbe a direct reference to what the caller passed in\n *    \t\t\t(i.e., it may be a shallow copy), so it can be freely\n *    \t\t\tmodified.\n *\n *    shortmessage      result of sprintf(sprintf_args), taking options.strict\n *    \t\t\tinto account as described in README.md.\n */ function parseConstructorArguments(args) {\n    var argv, options, sprintf_args, shortmessage, k;\n    mod_assertplus.object(args, \"args\");\n    mod_assertplus.bool(args.strict, \"args.strict\");\n    mod_assertplus.array(args.argv, \"args.argv\");\n    argv = args.argv;\n    /*\n\t * First, figure out which form of invocation we've been given.\n\t */ if (argv.length === 0) {\n        options = {};\n        sprintf_args = [];\n    } else if (mod_isError(argv[0])) {\n        options = {\n            \"cause\": argv[0]\n        };\n        sprintf_args = argv.slice(1);\n    } else if (typeof argv[0] === \"object\") {\n        options = {};\n        for(k in argv[0]){\n            options[k] = argv[0][k];\n        }\n        sprintf_args = argv.slice(1);\n    } else {\n        mod_assertplus.string(argv[0], \"first argument to VError, SError, or WError \" + \"constructor must be a string, object, or Error\");\n        options = {};\n        sprintf_args = argv;\n    }\n    /*\n\t * Now construct the error's message.\n\t *\n\t * extsprintf (which we invoke here with our caller's arguments in order\n\t * to construct this Error's message) is strict in its interpretation of\n\t * values to be processed by the \"%s\" specifier.  The value passed to\n\t * extsprintf must actually be a string or something convertible to a\n\t * String using .toString().  Passing other values (notably \"null\" and\n\t * \"undefined\") is considered a programmer error.  The assumption is\n\t * that if you actually want to print the string \"null\" or \"undefined\",\n\t * then that's easy to do that when you're calling extsprintf; on the\n\t * other hand, if you did NOT want that (i.e., there's actually a bug\n\t * where the program assumes some variable is non-null and tries to\n\t * print it, which might happen when constructing a packet or file in\n\t * some specific format), then it's better to stop immediately than\n\t * produce bogus output.\n\t *\n\t * However, sometimes the bug is only in the code calling VError, and a\n\t * programmer might prefer to have the error message contain \"null\" or\n\t * \"undefined\" rather than have the bug in the error path crash the\n\t * program (making the first bug harder to identify).  For that reason,\n\t * by default VError converts \"null\" or \"undefined\" arguments to their\n\t * string representations and passes those to extsprintf.  Programmers\n\t * desiring the strict behavior can use the SError class or pass the\n\t * \"strict\" option to the VError constructor.\n\t */ mod_assertplus.object(options);\n    if (!options.strict && !args.strict) {\n        sprintf_args = sprintf_args.map(function(a) {\n            return a === null ? \"null\" : a === undefined ? \"undefined\" : a;\n        });\n    }\n    if (sprintf_args.length === 0) {\n        shortmessage = \"\";\n    } else {\n        shortmessage = sprintf.apply(null, sprintf_args);\n    }\n    return {\n        \"options\": options,\n        \"shortmessage\": shortmessage\n    };\n}\n/*\n * See README.md for reference documentation.\n */ function VError() {\n    var args, obj, parsed, cause, ctor, message, k;\n    args = Array.prototype.slice.call(arguments, 0);\n    /*\n\t * This is a regrettable pattern, but JavaScript's built-in Error class\n\t * is defined to work this way, so we allow the constructor to be called\n\t * without \"new\".\n\t */ if (!(this instanceof VError)) {\n        obj = Object.create(VError.prototype);\n        VError.apply(obj, arguments);\n        return obj;\n    }\n    /*\n\t * For convenience and backwards compatibility, we support several\n\t * different calling forms.  Normalize them here.\n\t */ parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": false\n    });\n    /*\n\t * If we've been given a name, apply it now.\n\t */ if (parsed.options.name) {\n        mod_assertplus.string(parsed.options.name, 'error\\'s \"name\" must be a string');\n        this.name = parsed.options.name;\n    }\n    /*\n\t * For debugging, we keep track of the original short message (attached\n\t * this Error particularly) separately from the complete message (which\n\t * includes the messages of our cause chain).\n\t */ this.jse_shortmsg = parsed.shortmessage;\n    message = parsed.shortmessage;\n    /*\n\t * If we've been given a cause, record a reference to it and update our\n\t * message appropriately.\n\t */ cause = parsed.options.cause;\n    if (cause) {\n        mod_assertplus.ok(mod_isError(cause), \"cause is not an Error\");\n        this.jse_cause = cause;\n        if (!parsed.options.skipCauseMessage) {\n            message += \": \" + cause.message;\n        }\n    }\n    /*\n\t * If we've been given an object with properties, shallow-copy that\n\t * here.  We don't want to use a deep copy in case there are non-plain\n\t * objects here, but we don't want to use the original object in case\n\t * the caller modifies it later.\n\t */ this.jse_info = {};\n    if (parsed.options.info) {\n        for(k in parsed.options.info){\n            this.jse_info[k] = parsed.options.info[k];\n        }\n    }\n    this.message = message;\n    Error.call(this, message);\n    if (Error.captureStackTrace) {\n        ctor = parsed.options.constructorOpt || this.constructor;\n        Error.captureStackTrace(this, ctor);\n    }\n    return this;\n}\nmod_util.inherits(VError, Error);\nVError.prototype.name = \"VError\";\nVError.prototype.toString = function ve_toString() {\n    var str = this.hasOwnProperty(\"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n    if (this.message) str += \": \" + this.message;\n    return str;\n};\n/*\n * This method is provided for compatibility.  New callers should use\n * VError.cause() instead.  That method also uses the saner `null` return value\n * when there is no cause.\n */ VError.prototype.cause = function ve_cause() {\n    var cause = VError.cause(this);\n    return cause === null ? undefined : cause;\n};\n/*\n * Static methods\n *\n * These class-level methods are provided so that callers can use them on\n * instances of Errors that are not VErrors.  New interfaces should be provided\n * only using static methods to eliminate the class of programming mistake where\n * people fail to check whether the Error object has the corresponding methods.\n */ VError.cause = function(err) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    return mod_isError(err.jse_cause) ? err.jse_cause : null;\n};\nVError.info = function(err) {\n    var rv, cause, k;\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    cause = VError.cause(err);\n    if (cause !== null) {\n        rv = VError.info(cause);\n    } else {\n        rv = {};\n    }\n    if (typeof err.jse_info == \"object\" && err.jse_info !== null) {\n        for(k in err.jse_info){\n            rv[k] = err.jse_info[k];\n        }\n    }\n    return rv;\n};\nVError.findCauseByName = function(err, name) {\n    var cause;\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    mod_assertplus.string(name, \"name\");\n    mod_assertplus.ok(name.length > 0, \"name cannot be empty\");\n    for(cause = err; cause !== null; cause = VError.cause(cause)){\n        mod_assertplus.ok(mod_isError(cause));\n        if (cause.name == name) {\n            return cause;\n        }\n    }\n    return null;\n};\nVError.hasCauseWithName = function(err, name) {\n    return VError.findCauseByName(err, name) !== null;\n};\nVError.fullStack = function(err) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    var cause = VError.cause(err);\n    if (cause) {\n        return err.stack + \"\\ncaused by: \" + VError.fullStack(cause);\n    }\n    return err.stack;\n};\nVError.errorFromList = function(errors) {\n    mod_assertplus.arrayOfObject(errors, \"errors\");\n    if (errors.length === 0) {\n        return null;\n    }\n    errors.forEach(function(e) {\n        mod_assertplus.ok(mod_isError(e));\n    });\n    if (errors.length == 1) {\n        return errors[0];\n    }\n    return new MultiError(errors);\n};\nVError.errorForEach = function(err, func) {\n    mod_assertplus.ok(mod_isError(err), \"err must be an Error\");\n    mod_assertplus.func(func, \"func\");\n    if (err instanceof MultiError) {\n        err.errors().forEach(function iterError(e) {\n            func(e);\n        });\n    } else {\n        func(err);\n    }\n};\n/*\n * SError is like VError, but stricter about types.  You cannot pass \"null\" or\n * \"undefined\" as string arguments to the formatter.\n */ function SError() {\n    var args, obj, parsed, options;\n    args = Array.prototype.slice.call(arguments, 0);\n    if (!(this instanceof SError)) {\n        obj = Object.create(SError.prototype);\n        SError.apply(obj, arguments);\n        return obj;\n    }\n    parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": true\n    });\n    options = parsed.options;\n    VError.call(this, options, \"%s\", parsed.shortmessage);\n    return this;\n}\n/*\n * We don't bother setting SError.prototype.name because once constructed,\n * SErrors are just like VErrors.\n */ mod_util.inherits(SError, VError);\n/*\n * Represents a collection of errors for the purpose of consumers that generally\n * only deal with one error.  Callers can extract the individual errors\n * contained in this object, but may also just treat it as a normal single\n * error, in which case a summary message will be printed.\n */ function MultiError(errors) {\n    mod_assertplus.array(errors, \"list of errors\");\n    mod_assertplus.ok(errors.length > 0, \"must be at least one error\");\n    this.ase_errors = errors;\n    VError.call(this, {\n        \"cause\": errors[0]\n    }, \"first of %d error%s\", errors.length, errors.length == 1 ? \"\" : \"s\");\n}\nmod_util.inherits(MultiError, VError);\nMultiError.prototype.name = \"MultiError\";\nMultiError.prototype.errors = function me_errors() {\n    return this.ase_errors.slice(0);\n};\n/*\n * See README.md for reference details.\n */ function WError() {\n    var args, obj, parsed, options;\n    args = Array.prototype.slice.call(arguments, 0);\n    if (!(this instanceof WError)) {\n        obj = Object.create(WError.prototype);\n        WError.apply(obj, args);\n        return obj;\n    }\n    parsed = parseConstructorArguments({\n        \"argv\": args,\n        \"strict\": false\n    });\n    options = parsed.options;\n    options[\"skipCauseMessage\"] = true;\n    VError.call(this, options, \"%s\", parsed.shortmessage);\n    return this;\n}\nmod_util.inherits(WError, VError);\nWError.prototype.name = \"WError\";\nWError.prototype.toString = function we_toString() {\n    var str = this.hasOwnProperty(\"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n    if (this.message) str += \": \" + this.message;\n    if (this.jse_cause && this.jse_cause.message) str += \"; caused by \" + this.jse_cause.toString();\n    return str;\n};\n/*\n * For purely historical reasons, WError's cause() function allows you to set\n * the cause.\n */ WError.prototype.cause = function we_cause(c) {\n    if (mod_isError(c)) this.jse_cause = c;\n    return this.jse_cause;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy92ZXJyb3IvbGliL3ZlcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQztBQUVELElBQUlBLGlCQUFpQkMsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUM7QUFFdkIsSUFBSUUsaUJBQWlCRixtQkFBT0EsQ0FBQztBQUM3QixJQUFJRyxjQUFjSCw2R0FBK0I7QUFDakQsSUFBSUssVUFBVUgsZUFBZUcsT0FBTztBQUVwQzs7Q0FFQyxHQUVELCtDQUErQyxHQUMvQ0MsT0FBT0MsT0FBTyxHQUFHQztBQUNqQixxQkFBcUIsR0FDckJBLE9BQU9BLE1BQU0sR0FBR0E7QUFDaEIsMEJBQTBCLEdBQzFCQSxPQUFPQyxNQUFNLEdBQUdBO0FBQ2hCRCxPQUFPRSxNQUFNLEdBQUdBO0FBQ2hCRixPQUFPRyxVQUFVLEdBQUdBO0FBRXBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeUJDLEdBQ0QsU0FBU0MsMEJBQTBCQyxJQUFJO0lBRXRDLElBQUlDLE1BQU1DLFNBQVNDLGNBQWNDLGNBQWNDO0lBRS9DbkIsZUFBZW9CLE1BQU0sQ0FBQ04sTUFBTTtJQUM1QmQsZUFBZXFCLElBQUksQ0FBQ1AsS0FBS1EsTUFBTSxFQUFFO0lBQ2pDdEIsZUFBZXVCLEtBQUssQ0FBQ1QsS0FBS0MsSUFBSSxFQUFFO0lBQ2hDQSxPQUFPRCxLQUFLQyxJQUFJO0lBRWhCOztFQUVDLEdBQ0QsSUFBSUEsS0FBS1MsTUFBTSxLQUFLLEdBQUc7UUFDdEJSLFVBQVUsQ0FBQztRQUNYQyxlQUFlLEVBQUU7SUFDbEIsT0FBTyxJQUFJYixZQUFZVyxJQUFJLENBQUMsRUFBRSxHQUFHO1FBQ2hDQyxVQUFVO1lBQUUsU0FBU0QsSUFBSSxDQUFDLEVBQUU7UUFBQztRQUM3QkUsZUFBZUYsS0FBS1UsS0FBSyxDQUFDO0lBQzNCLE9BQU8sSUFBSSxPQUFRVixJQUFJLENBQUMsRUFBRSxLQUFNLFVBQVU7UUFDekNDLFVBQVUs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QUFTLENBQUNpQixRQUFRLEdBQUcsU0FBU3FCO0lBRXBDLElBQUluQixNQUFPLElBQUksQ0FBQ0MsY0FBYyxDQUFDLFdBQVcsSUFBSSxDQUFDZixJQUFJLElBQ2xELElBQUksQ0FBQ1UsV0FBVyxDQUFDVixJQUFJLElBQUksSUFBSSxDQUFDVSxXQUFXLENBQUNmLFNBQVMsQ0FBQ0ssSUFBSTtJQUN6RCxJQUFJLElBQUksQ0FBQ1AsT0FBTyxFQUNmcUIsT0FBTyxPQUFPLElBQUksQ0FBQ3JCLE9BQU87SUFDM0IsSUFBSSxJQUFJLENBQUNVLFNBQVMsSUFBSSxJQUFJLENBQUNBLFNBQVMsQ0FBQ1YsT0FBTyxFQUMzQ3FCLE9BQU8saUJBQWlCLElBQUksQ0FBQ1gsU0FBUyxDQUFDUyxRQUFRO0lBRWhELE9BQVFFO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRDdDLE9BQU8wQixTQUFTLENBQUNKLEtBQUssR0FBRyxTQUFTMkMsU0FBU0MsQ0FBQztJQUUzQyxJQUFJekUsWUFBWXlFLElBQ2YsSUFBSSxDQUFDaEMsU0FBUyxHQUFHZ0M7SUFFbEIsT0FBUSxJQUFJLENBQUNoQyxTQUFTO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5ub3ZhdGlvbi1jb2FjaC8uL25vZGVfbW9kdWxlcy92ZXJyb3IvbGliL3ZlcnJvci5qcz9mMGE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiB2ZXJyb3IuanM6IHJpY2hlciBKYXZhU2NyaXB0IGVycm9yc1xuICovXG5cbnZhciBtb2RfYXNzZXJ0cGx1cyA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgbW9kX3V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBtb2RfZXh0c3ByaW50ZiA9IHJlcXVpcmUoJ2V4dHNwcmludGYnKTtcbnZhciBtb2RfaXNFcnJvciA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpLmlzRXJyb3I7XG52YXIgc3ByaW50ZiA9IG1vZF9leHRzcHJpbnRmLnNwcmludGY7XG5cbi8qXG4gKiBQdWJsaWMgaW50ZXJmYWNlXG4gKi9cblxuLyogU28geW91IGNhbiAndmFyIFZFcnJvciA9IHJlcXVpcmUoJ3ZlcnJvcicpJyAqL1xubW9kdWxlLmV4cG9ydHMgPSBWRXJyb3I7XG4vKiBGb3IgY29tcGF0aWJpbGl0eSAqL1xuVkVycm9yLlZFcnJvciA9IFZFcnJvcjtcbi8qIE90aGVyIGV4cG9ydGVkIGNsYXNzZXMgKi9cblZFcnJvci5TRXJyb3IgPSBTRXJyb3I7XG5WRXJyb3IuV0Vycm9yID0gV0Vycm9yO1xuVkVycm9yLk11bHRpRXJyb3IgPSBNdWx0aUVycm9yO1xuXG4vKlxuICogQ29tbW9uIGZ1bmN0aW9uIHVzZWQgdG8gcGFyc2UgY29uc3RydWN0b3IgYXJndW1lbnRzIGZvciBWRXJyb3IsIFdFcnJvciwgYW5kXG4gKiBTRXJyb3IuICBOYW1lZCBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbjpcbiAqXG4gKiAgICAgc3RyaWN0XHRcdGZvcmNlIHN0cmljdCBpbnRlcnByZXRhdGlvbiBvZiBzcHJpbnRmIGFyZ3VtZW50cywgZXZlblxuICogICAgIFx0XHRcdGlmIHRoZSBvcHRpb25zIGluIFwiYXJndlwiIGRvbid0IHNheSBzb1xuICpcbiAqICAgICBhcmd2XHRcdGVycm9yJ3MgY29uc3RydWN0b3IgYXJndW1lbnRzLCB3aGljaCBhcmUgdG8gYmVcbiAqICAgICBcdFx0XHRpbnRlcnByZXRlZCBhcyBkZXNjcmliZWQgaW4gUkVBRE1FLm1kLiAgRm9yIHF1aWNrXG4gKiAgICAgXHRcdFx0cmVmZXJlbmNlLCBcImFyZ3ZcIiBoYXMgb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gKlxuICogICAgICAgICAgWyBzcHJpbnRmX2FyZ3MuLi4gXSAgICAgICAgICAgKGFyZ3ZbMF0gaXMgYSBzdHJpbmcpXG4gKiAgICAgICAgICBbIGNhdXNlLCBzcHJpbnRmX2FyZ3MuLi4gXSAgICAoYXJndlswXSBpcyBhbiBFcnJvcilcbiAqICAgICAgICAgIFsgb3B0aW9ucywgc3ByaW50Zl9hcmdzLi4uIF0gIChhcmd2WzBdIGlzIGFuIG9iamVjdClcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG5vcm1hbGl6ZXMgdGhlc2UgZm9ybXMsIHByb2R1Y2luZyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgIG9wdGlvbnMgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gXCJvcHRpb25zXCIgaW4gdGhpcmQgZm9ybS4gIFRoaXMgd2lsbCBuZXZlclxuICogICAgXHRcdFx0YmUgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHdoYXQgdGhlIGNhbGxlciBwYXNzZWQgaW5cbiAqICAgIFx0XHRcdChpLmUuLCBpdCBtYXkgYmUgYSBzaGFsbG93IGNvcHkpLCBzbyBpdCBjYW4gYmUgZnJlZWx5XG4gKiAgICBcdFx0XHRtb2RpZmllZC5cbiAqXG4gKiAgICBzaG9ydG1lc3NhZ2UgICAgICByZXN1bHQgb2Ygc3ByaW50ZihzcHJpbnRmX2FyZ3MpLCB0YWtpbmcgb3B0aW9ucy5zdHJpY3RcbiAqICAgIFx0XHRcdGludG8gYWNjb3VudCBhcyBkZXNjcmliZWQgaW4gUkVBRE1FLm1kLlxuICovXG5mdW5jdGlvbiBwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzKGFyZ3MpXG57XG5cdHZhciBhcmd2LCBvcHRpb25zLCBzcHJpbnRmX2FyZ3MsIHNob3J0bWVzc2FnZSwgaztcblxuXHRtb2RfYXNzZXJ0cGx1cy5vYmplY3QoYXJncywgJ2FyZ3MnKTtcblx0bW9kX2Fzc2VydHBsdXMuYm9vbChhcmdzLnN0cmljdCwgJ2FyZ3Muc3RyaWN0Jyk7XG5cdG1vZF9hc3NlcnRwbHVzLmFycmF5KGFyZ3MuYXJndiwgJ2FyZ3MuYXJndicpO1xuXHRhcmd2ID0gYXJncy5hcmd2O1xuXG5cdC8qXG5cdCAqIEZpcnN0LCBmaWd1cmUgb3V0IHdoaWNoIGZvcm0gb2YgaW52b2NhdGlvbiB3ZSd2ZSBiZWVuIGdpdmVuLlxuXHQgKi9cblx0aWYgKGFyZ3YubGVuZ3RoID09PSAwKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRcdHNwcmludGZfYXJncyA9IFtdO1xuXHR9IGVsc2UgaWYgKG1vZF9pc0Vycm9yKGFyZ3ZbMF0pKSB7XG5cdFx0b3B0aW9ucyA9IHsgJ2NhdXNlJzogYXJndlswXSB9O1xuXHRcdHNwcmludGZfYXJncyA9IGFyZ3Yuc2xpY2UoMSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIChhcmd2WzBdKSA9PT0gJ29iamVjdCcpIHtcblx0XHRvcHRpb25zID0ge307XG5cdFx0Zm9yIChrIGluIGFyZ3ZbMF0pIHtcblx0XHRcdG9wdGlvbnNba10gPSBhcmd2WzBdW2tdO1xuXHRcdH1cblx0XHRzcHJpbnRmX2FyZ3MgPSBhcmd2LnNsaWNlKDEpO1xuXHR9IGVsc2Uge1xuXHRcdG1vZF9hc3NlcnRwbHVzLnN0cmluZyhhcmd2WzBdLFxuXHRcdCAgICAnZmlyc3QgYXJndW1lbnQgdG8gVkVycm9yLCBTRXJyb3IsIG9yIFdFcnJvciAnICtcblx0XHQgICAgJ2NvbnN0cnVjdG9yIG11c3QgYmUgYSBzdHJpbmcsIG9iamVjdCwgb3IgRXJyb3InKTtcblx0XHRvcHRpb25zID0ge307XG5cdFx0c3ByaW50Zl9hcmdzID0gYXJndjtcblx0fVxuXG5cdC8qXG5cdCAqIE5vdyBjb25zdHJ1Y3QgdGhlIGVycm9yJ3MgbWVzc2FnZS5cblx0ICpcblx0ICogZXh0c3ByaW50ZiAod2hpY2ggd2UgaW52b2tlIGhlcmUgd2l0aCBvdXIgY2FsbGVyJ3MgYXJndW1lbnRzIGluIG9yZGVyXG5cdCAqIHRvIGNvbnN0cnVjdCB0aGlzIEVycm9yJ3MgbWVzc2FnZSkgaXMgc3RyaWN0IGluIGl0cyBpbnRlcnByZXRhdGlvbiBvZlxuXHQgKiB2YWx1ZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHRoZSBcIiVzXCIgc3BlY2lmaWVyLiAgVGhlIHZhbHVlIHBhc3NlZCB0b1xuXHQgKiBleHRzcHJpbnRmIG11c3QgYWN0dWFsbHkgYmUgYSBzdHJpbmcgb3Igc29tZXRoaW5nIGNvbnZlcnRpYmxlIHRvIGFcblx0ICogU3RyaW5nIHVzaW5nIC50b1N0cmluZygpLiAgUGFzc2luZyBvdGhlciB2YWx1ZXMgKG5vdGFibHkgXCJudWxsXCIgYW5kXG5cdCAqIFwidW5kZWZpbmVkXCIpIGlzIGNvbnNpZGVyZWQgYSBwcm9ncmFtbWVyIGVycm9yLiAgVGhlIGFzc3VtcHRpb24gaXNcblx0ICogdGhhdCBpZiB5b3UgYWN0dWFsbHkgd2FudCB0byBwcmludCB0aGUgc3RyaW5nIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIsXG5cdCAqIHRoZW4gdGhhdCdzIGVhc3kgdG8gZG8gdGhhdCB3aGVuIHlvdSdyZSBjYWxsaW5nIGV4dHNwcmludGY7IG9uIHRoZVxuXHQgKiBvdGhlciBoYW5kLCBpZiB5b3UgZGlkIE5PVCB3YW50IHRoYXQgKGkuZS4sIHRoZXJlJ3MgYWN0dWFsbHkgYSBidWdcblx0ICogd2hlcmUgdGhlIHByb2dyYW0gYXNzdW1lcyBzb21lIHZhcmlhYmxlIGlzIG5vbi1udWxsIGFuZCB0cmllcyB0b1xuXHQgKiBwcmludCBpdCwgd2hpY2ggbWlnaHQgaGFwcGVuIHdoZW4gY29uc3RydWN0aW5nIGEgcGFja2V0IG9yIGZpbGUgaW5cblx0ICogc29tZSBzcGVjaWZpYyBmb3JtYXQpLCB0aGVuIGl0J3MgYmV0dGVyIHRvIHN0b3AgaW1tZWRpYXRlbHkgdGhhblxuXHQgKiBwcm9kdWNlIGJvZ3VzIG91dHB1dC5cblx0ICpcblx0ICogSG93ZXZlciwgc29tZXRpbWVzIHRoZSBidWcgaXMgb25seSBpbiB0aGUgY29kZSBjYWxsaW5nIFZFcnJvciwgYW5kIGFcblx0ICogcHJvZ3JhbW1lciBtaWdodCBwcmVmZXIgdG8gaGF2ZSB0aGUgZXJyb3IgbWVzc2FnZSBjb250YWluIFwibnVsbFwiIG9yXG5cdCAqIFwidW5kZWZpbmVkXCIgcmF0aGVyIHRoYW4gaGF2ZSB0aGUgYnVnIGluIHRoZSBlcnJvciBwYXRoIGNyYXNoIHRoZVxuXHQgKiBwcm9ncmFtIChtYWtpbmcgdGhlIGZpcnN0IGJ1ZyBoYXJkZXIgdG8gaWRlbnRpZnkpLiAgRm9yIHRoYXQgcmVhc29uLFxuXHQgKiBieSBkZWZhdWx0IFZFcnJvciBjb252ZXJ0cyBcIm51bGxcIiBvciBcInVuZGVmaW5lZFwiIGFyZ3VtZW50cyB0byB0aGVpclxuXHQgKiBzdHJpbmcgcmVwcmVzZW50YXRpb25zIGFuZCBwYXNzZXMgdGhvc2UgdG8gZXh0c3ByaW50Zi4gIFByb2dyYW1tZXJzXG5cdCAqIGRlc2lyaW5nIHRoZSBzdHJpY3QgYmVoYXZpb3IgY2FuIHVzZSB0aGUgU0Vycm9yIGNsYXNzIG9yIHBhc3MgdGhlXG5cdCAqIFwic3RyaWN0XCIgb3B0aW9uIHRvIHRoZSBWRXJyb3IgY29uc3RydWN0b3IuXG5cdCAqL1xuXHRtb2RfYXNzZXJ0cGx1cy5vYmplY3Qob3B0aW9ucyk7XG5cdGlmICghb3B0aW9ucy5zdHJpY3QgJiYgIWFyZ3Muc3RyaWN0KSB7XG5cdFx0c3ByaW50Zl9hcmdzID0gc3ByaW50Zl9hcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuXHRcdFx0cmV0dXJuIChhID09PSBudWxsID8gJ251bGwnIDpcblx0XHRcdCAgICBhID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IGEpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKHNwcmludGZfYXJncy5sZW5ndGggPT09IDApIHtcblx0XHRzaG9ydG1lc3NhZ2UgPSAnJztcblx0fSBlbHNlIHtcblx0XHRzaG9ydG1lc3NhZ2UgPSBzcHJpbnRmLmFwcGx5KG51bGwsIHNwcmludGZfYXJncyk7XG5cdH1cblxuXHRyZXR1cm4gKHtcblx0ICAgICdvcHRpb25zJzogb3B0aW9ucyxcblx0ICAgICdzaG9ydG1lc3NhZ2UnOiBzaG9ydG1lc3NhZ2Vcblx0fSk7XG59XG5cbi8qXG4gKiBTZWUgUkVBRE1FLm1kIGZvciByZWZlcmVuY2UgZG9jdW1lbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gVkVycm9yKClcbntcblx0dmFyIGFyZ3MsIG9iaiwgcGFyc2VkLCBjYXVzZSwgY3RvciwgbWVzc2FnZSwgaztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuXHQvKlxuXHQgKiBUaGlzIGlzIGEgcmVncmV0dGFibGUgcGF0dGVybiwgYnV0IEphdmFTY3JpcHQncyBidWlsdC1pbiBFcnJvciBjbGFzc1xuXHQgKiBpcyBkZWZpbmVkIHRvIHdvcmsgdGhpcyB3YXksIHNvIHdlIGFsbG93IHRoZSBjb25zdHJ1Y3RvciB0byBiZSBjYWxsZWRcblx0ICogd2l0aG91dCBcIm5ld1wiLlxuXHQgKi9cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFZFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFZFcnJvci5wcm90b3R5cGUpO1xuXHRcdFZFcnJvci5hcHBseShvYmosIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIChvYmopO1xuXHR9XG5cblx0Lypcblx0ICogRm9yIGNvbnZlbmllbmNlIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCBzZXZlcmFsXG5cdCAqIGRpZmZlcmVudCBjYWxsaW5nIGZvcm1zLiAgTm9ybWFsaXplIHRoZW0gaGVyZS5cblx0ICovXG5cdHBhcnNlZCA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoe1xuXHQgICAgJ2FyZ3YnOiBhcmdzLFxuXHQgICAgJ3N0cmljdCc6IGZhbHNlXG5cdH0pO1xuXG5cdC8qXG5cdCAqIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBuYW1lLCBhcHBseSBpdCBub3cuXG5cdCAqL1xuXHRpZiAocGFyc2VkLm9wdGlvbnMubmFtZSkge1xuXHRcdG1vZF9hc3NlcnRwbHVzLnN0cmluZyhwYXJzZWQub3B0aW9ucy5uYW1lLFxuXHRcdCAgICAnZXJyb3JcXCdzIFwibmFtZVwiIG11c3QgYmUgYSBzdHJpbmcnKTtcblx0XHR0aGlzLm5hbWUgPSBwYXJzZWQub3B0aW9ucy5uYW1lO1xuXHR9XG5cblx0Lypcblx0ICogRm9yIGRlYnVnZ2luZywgd2Uga2VlcCB0cmFjayBvZiB0aGUgb3JpZ2luYWwgc2hvcnQgbWVzc2FnZSAoYXR0YWNoZWRcblx0ICogdGhpcyBFcnJvciBwYXJ0aWN1bGFybHkpIHNlcGFyYXRlbHkgZnJvbSB0aGUgY29tcGxldGUgbWVzc2FnZSAod2hpY2hcblx0ICogaW5jbHVkZXMgdGhlIG1lc3NhZ2VzIG9mIG91ciBjYXVzZSBjaGFpbikuXG5cdCAqL1xuXHR0aGlzLmpzZV9zaG9ydG1zZyA9IHBhcnNlZC5zaG9ydG1lc3NhZ2U7XG5cdG1lc3NhZ2UgPSBwYXJzZWQuc2hvcnRtZXNzYWdlO1xuXG5cdC8qXG5cdCAqIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjYXVzZSwgcmVjb3JkIGEgcmVmZXJlbmNlIHRvIGl0IGFuZCB1cGRhdGUgb3VyXG5cdCAqIG1lc3NhZ2UgYXBwcm9wcmlhdGVseS5cblx0ICovXG5cdGNhdXNlID0gcGFyc2VkLm9wdGlvbnMuY2F1c2U7XG5cdGlmIChjYXVzZSkge1xuXHRcdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGNhdXNlKSwgJ2NhdXNlIGlzIG5vdCBhbiBFcnJvcicpO1xuXHRcdHRoaXMuanNlX2NhdXNlID0gY2F1c2U7XG5cblx0XHRpZiAoIXBhcnNlZC5vcHRpb25zLnNraXBDYXVzZU1lc3NhZ2UpIHtcblx0XHRcdG1lc3NhZ2UgKz0gJzogJyArIGNhdXNlLm1lc3NhZ2U7XG5cdFx0fVxuXHR9XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzLCBzaGFsbG93LWNvcHkgdGhhdFxuXHQgKiBoZXJlLiAgV2UgZG9uJ3Qgd2FudCB0byB1c2UgYSBkZWVwIGNvcHkgaW4gY2FzZSB0aGVyZSBhcmUgbm9uLXBsYWluXG5cdCAqIG9iamVjdHMgaGVyZSwgYnV0IHdlIGRvbid0IHdhbnQgdG8gdXNlIHRoZSBvcmlnaW5hbCBvYmplY3QgaW4gY2FzZVxuXHQgKiB0aGUgY2FsbGVyIG1vZGlmaWVzIGl0IGxhdGVyLlxuXHQgKi9cblx0dGhpcy5qc2VfaW5mbyA9IHt9O1xuXHRpZiAocGFyc2VkLm9wdGlvbnMuaW5mbykge1xuXHRcdGZvciAoayBpbiBwYXJzZWQub3B0aW9ucy5pbmZvKSB7XG5cdFx0XHR0aGlzLmpzZV9pbmZvW2tdID0gcGFyc2VkLm9wdGlvbnMuaW5mb1trXTtcblx0XHR9XG5cdH1cblxuXHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG5cdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuXHRcdGN0b3IgPSBwYXJzZWQub3B0aW9ucy5jb25zdHJ1Y3Rvck9wdCB8fCB0aGlzLmNvbnN0cnVjdG9yO1xuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGN0b3IpO1xuXHR9XG5cblx0cmV0dXJuICh0aGlzKTtcbn1cblxubW9kX3V0aWwuaW5oZXJpdHMoVkVycm9yLCBFcnJvcik7XG5WRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnVkVycm9yJztcblxuVkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHZlX3RvU3RyaW5nKClcbntcblx0dmFyIHN0ciA9ICh0aGlzLmhhc093blByb3BlcnR5KCduYW1lJykgJiYgdGhpcy5uYW1lIHx8XG5cdFx0dGhpcy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLm5hbWUpO1xuXHRpZiAodGhpcy5tZXNzYWdlKVxuXHRcdHN0ciArPSAnOiAnICsgdGhpcy5tZXNzYWdlO1xuXG5cdHJldHVybiAoc3RyKTtcbn07XG5cbi8qXG4gKiBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBmb3IgY29tcGF0aWJpbGl0eS4gIE5ldyBjYWxsZXJzIHNob3VsZCB1c2VcbiAqIFZFcnJvci5jYXVzZSgpIGluc3RlYWQuICBUaGF0IG1ldGhvZCBhbHNvIHVzZXMgdGhlIHNhbmVyIGBudWxsYCByZXR1cm4gdmFsdWVcbiAqIHdoZW4gdGhlcmUgaXMgbm8gY2F1c2UuXG4gKi9cblZFcnJvci5wcm90b3R5cGUuY2F1c2UgPSBmdW5jdGlvbiB2ZV9jYXVzZSgpXG57XG5cdHZhciBjYXVzZSA9IFZFcnJvci5jYXVzZSh0aGlzKTtcblx0cmV0dXJuIChjYXVzZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGNhdXNlKTtcbn07XG5cbi8qXG4gKiBTdGF0aWMgbWV0aG9kc1xuICpcbiAqIFRoZXNlIGNsYXNzLWxldmVsIG1ldGhvZHMgYXJlIHByb3ZpZGVkIHNvIHRoYXQgY2FsbGVycyBjYW4gdXNlIHRoZW0gb25cbiAqIGluc3RhbmNlcyBvZiBFcnJvcnMgdGhhdCBhcmUgbm90IFZFcnJvcnMuICBOZXcgaW50ZXJmYWNlcyBzaG91bGQgYmUgcHJvdmlkZWRcbiAqIG9ubHkgdXNpbmcgc3RhdGljIG1ldGhvZHMgdG8gZWxpbWluYXRlIHRoZSBjbGFzcyBvZiBwcm9ncmFtbWluZyBtaXN0YWtlIHdoZXJlXG4gKiBwZW9wbGUgZmFpbCB0byBjaGVjayB3aGV0aGVyIHRoZSBFcnJvciBvYmplY3QgaGFzIHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZHMuXG4gKi9cblxuVkVycm9yLmNhdXNlID0gZnVuY3Rpb24gKGVycilcbntcblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cdHJldHVybiAobW9kX2lzRXJyb3IoZXJyLmpzZV9jYXVzZSkgPyBlcnIuanNlX2NhdXNlIDogbnVsbCk7XG59O1xuXG5WRXJyb3IuaW5mbyA9IGZ1bmN0aW9uIChlcnIpXG57XG5cdHZhciBydiwgY2F1c2UsIGs7XG5cblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cdGNhdXNlID0gVkVycm9yLmNhdXNlKGVycik7XG5cdGlmIChjYXVzZSAhPT0gbnVsbCkge1xuXHRcdHJ2ID0gVkVycm9yLmluZm8oY2F1c2UpO1xuXHR9IGVsc2Uge1xuXHRcdHJ2ID0ge307XG5cdH1cblxuXHRpZiAodHlwZW9mIChlcnIuanNlX2luZm8pID09ICdvYmplY3QnICYmIGVyci5qc2VfaW5mbyAhPT0gbnVsbCkge1xuXHRcdGZvciAoayBpbiBlcnIuanNlX2luZm8pIHtcblx0XHRcdHJ2W2tdID0gZXJyLmpzZV9pbmZvW2tdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAocnYpO1xufTtcblxuVkVycm9yLmZpbmRDYXVzZUJ5TmFtZSA9IGZ1bmN0aW9uIChlcnIsIG5hbWUpXG57XG5cdHZhciBjYXVzZTtcblxuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKG5hbWUsICduYW1lJyk7XG5cdG1vZF9hc3NlcnRwbHVzLm9rKG5hbWUubGVuZ3RoID4gMCwgJ25hbWUgY2Fubm90IGJlIGVtcHR5Jyk7XG5cblx0Zm9yIChjYXVzZSA9IGVycjsgY2F1c2UgIT09IG51bGw7IGNhdXNlID0gVkVycm9yLmNhdXNlKGNhdXNlKSkge1xuXHRcdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGNhdXNlKSk7XG5cdFx0aWYgKGNhdXNlLm5hbWUgPT0gbmFtZSkge1xuXHRcdFx0cmV0dXJuIChjYXVzZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChudWxsKTtcbn07XG5cblZFcnJvci5oYXNDYXVzZVdpdGhOYW1lID0gZnVuY3Rpb24gKGVyciwgbmFtZSlcbntcblx0cmV0dXJuIChWRXJyb3IuZmluZENhdXNlQnlOYW1lKGVyciwgbmFtZSkgIT09IG51bGwpO1xufTtcblxuVkVycm9yLmZ1bGxTdGFjayA9IGZ1bmN0aW9uIChlcnIpXG57XG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXG5cdHZhciBjYXVzZSA9IFZFcnJvci5jYXVzZShlcnIpO1xuXG5cdGlmIChjYXVzZSkge1xuXHRcdHJldHVybiAoZXJyLnN0YWNrICsgJ1xcbmNhdXNlZCBieTogJyArIFZFcnJvci5mdWxsU3RhY2soY2F1c2UpKTtcblx0fVxuXG5cdHJldHVybiAoZXJyLnN0YWNrKTtcbn07XG5cblZFcnJvci5lcnJvckZyb21MaXN0ID0gZnVuY3Rpb24gKGVycm9ycylcbntcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXlPZk9iamVjdChlcnJvcnMsICdlcnJvcnMnKTtcblxuXHRpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiAobnVsbCk7XG5cdH1cblxuXHRlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGUpKTtcblx0fSk7XG5cblx0aWYgKGVycm9ycy5sZW5ndGggPT0gMSkge1xuXHRcdHJldHVybiAoZXJyb3JzWzBdKTtcblx0fVxuXG5cdHJldHVybiAobmV3IE11bHRpRXJyb3IoZXJyb3JzKSk7XG59O1xuXG5WRXJyb3IuZXJyb3JGb3JFYWNoID0gZnVuY3Rpb24gKGVyciwgZnVuYylcbntcblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cdG1vZF9hc3NlcnRwbHVzLmZ1bmMoZnVuYywgJ2Z1bmMnKTtcblxuXHRpZiAoZXJyIGluc3RhbmNlb2YgTXVsdGlFcnJvcikge1xuXHRcdGVyci5lcnJvcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIGl0ZXJFcnJvcihlKSB7IGZ1bmMoZSk7IH0pO1xuXHR9IGVsc2Uge1xuXHRcdGZ1bmMoZXJyKTtcblx0fVxufTtcblxuXG4vKlxuICogU0Vycm9yIGlzIGxpa2UgVkVycm9yLCBidXQgc3RyaWN0ZXIgYWJvdXQgdHlwZXMuICBZb3UgY2Fubm90IHBhc3MgXCJudWxsXCIgb3JcbiAqIFwidW5kZWZpbmVkXCIgYXMgc3RyaW5nIGFyZ3VtZW50cyB0byB0aGUgZm9ybWF0dGVyLlxuICovXG5mdW5jdGlvbiBTRXJyb3IoKVxue1xuXHR2YXIgYXJncywgb2JqLCBwYXJzZWQsIG9wdGlvbnM7XG5cblx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBTRXJyb3IpKSB7XG5cdFx0b2JqID0gT2JqZWN0LmNyZWF0ZShTRXJyb3IucHJvdG90eXBlKTtcblx0XHRTRXJyb3IuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiAob2JqKTtcblx0fVxuXG5cdHBhcnNlZCA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoe1xuXHQgICAgJ2FyZ3YnOiBhcmdzLFxuXHQgICAgJ3N0cmljdCc6IHRydWVcblx0fSk7XG5cblx0b3B0aW9ucyA9IHBhcnNlZC5vcHRpb25zO1xuXHRWRXJyb3IuY2FsbCh0aGlzLCBvcHRpb25zLCAnJXMnLCBwYXJzZWQuc2hvcnRtZXNzYWdlKTtcblxuXHRyZXR1cm4gKHRoaXMpO1xufVxuXG4vKlxuICogV2UgZG9uJ3QgYm90aGVyIHNldHRpbmcgU0Vycm9yLnByb3RvdHlwZS5uYW1lIGJlY2F1c2Ugb25jZSBjb25zdHJ1Y3RlZCxcbiAqIFNFcnJvcnMgYXJlIGp1c3QgbGlrZSBWRXJyb3JzLlxuICovXG5tb2RfdXRpbC5pbmhlcml0cyhTRXJyb3IsIFZFcnJvcik7XG5cblxuLypcbiAqIFJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGVycm9ycyBmb3IgdGhlIHB1cnBvc2Ugb2YgY29uc3VtZXJzIHRoYXQgZ2VuZXJhbGx5XG4gKiBvbmx5IGRlYWwgd2l0aCBvbmUgZXJyb3IuICBDYWxsZXJzIGNhbiBleHRyYWN0IHRoZSBpbmRpdmlkdWFsIGVycm9yc1xuICogY29udGFpbmVkIGluIHRoaXMgb2JqZWN0LCBidXQgbWF5IGFsc28ganVzdCB0cmVhdCBpdCBhcyBhIG5vcm1hbCBzaW5nbGVcbiAqIGVycm9yLCBpbiB3aGljaCBjYXNlIGEgc3VtbWFyeSBtZXNzYWdlIHdpbGwgYmUgcHJpbnRlZC5cbiAqL1xuZnVuY3Rpb24gTXVsdGlFcnJvcihlcnJvcnMpXG57XG5cdG1vZF9hc3NlcnRwbHVzLmFycmF5KGVycm9ycywgJ2xpc3Qgb2YgZXJyb3JzJyk7XG5cdG1vZF9hc3NlcnRwbHVzLm9rKGVycm9ycy5sZW5ndGggPiAwLCAnbXVzdCBiZSBhdCBsZWFzdCBvbmUgZXJyb3InKTtcblx0dGhpcy5hc2VfZXJyb3JzID0gZXJyb3JzO1xuXG5cdFZFcnJvci5jYWxsKHRoaXMsIHtcblx0ICAgICdjYXVzZSc6IGVycm9yc1swXVxuXHR9LCAnZmlyc3Qgb2YgJWQgZXJyb3IlcycsIGVycm9ycy5sZW5ndGgsIGVycm9ycy5sZW5ndGggPT0gMSA/ICcnIDogJ3MnKTtcbn1cblxubW9kX3V0aWwuaW5oZXJpdHMoTXVsdGlFcnJvciwgVkVycm9yKTtcbk11bHRpRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnTXVsdGlFcnJvcic7XG5cbk11bHRpRXJyb3IucHJvdG90eXBlLmVycm9ycyA9IGZ1bmN0aW9uIG1lX2Vycm9ycygpXG57XG5cdHJldHVybiAodGhpcy5hc2VfZXJyb3JzLnNsaWNlKDApKTtcbn07XG5cblxuLypcbiAqIFNlZSBSRUFETUUubWQgZm9yIHJlZmVyZW5jZSBkZXRhaWxzLlxuICovXG5mdW5jdGlvbiBXRXJyb3IoKVxue1xuXHR2YXIgYXJncywgb2JqLCBwYXJzZWQsIG9wdGlvbnM7XG5cblx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBXRXJyb3IpKSB7XG5cdFx0b2JqID0gT2JqZWN0LmNyZWF0ZShXRXJyb3IucHJvdG90eXBlKTtcblx0XHRXRXJyb3IuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRyZXR1cm4gKG9iaik7XG5cdH1cblxuXHRwYXJzZWQgPSBwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzKHtcblx0ICAgICdhcmd2JzogYXJncyxcblx0ICAgICdzdHJpY3QnOiBmYWxzZVxuXHR9KTtcblxuXHRvcHRpb25zID0gcGFyc2VkLm9wdGlvbnM7XG5cdG9wdGlvbnNbJ3NraXBDYXVzZU1lc3NhZ2UnXSA9IHRydWU7XG5cdFZFcnJvci5jYWxsKHRoaXMsIG9wdGlvbnMsICclcycsIHBhcnNlZC5zaG9ydG1lc3NhZ2UpO1xuXG5cdHJldHVybiAodGhpcyk7XG59XG5cbm1vZF91dGlsLmluaGVyaXRzKFdFcnJvciwgVkVycm9yKTtcbldFcnJvci5wcm90b3R5cGUubmFtZSA9ICdXRXJyb3InO1xuXG5XRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gd2VfdG9TdHJpbmcoKVxue1xuXHR2YXIgc3RyID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiB0aGlzLm5hbWUgfHxcblx0XHR0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSk7XG5cdGlmICh0aGlzLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc6ICcgKyB0aGlzLm1lc3NhZ2U7XG5cdGlmICh0aGlzLmpzZV9jYXVzZSAmJiB0aGlzLmpzZV9jYXVzZS5tZXNzYWdlKVxuXHRcdHN0ciArPSAnOyBjYXVzZWQgYnkgJyArIHRoaXMuanNlX2NhdXNlLnRvU3RyaW5nKCk7XG5cblx0cmV0dXJuIChzdHIpO1xufTtcblxuLypcbiAqIEZvciBwdXJlbHkgaGlzdG9yaWNhbCByZWFzb25zLCBXRXJyb3IncyBjYXVzZSgpIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0XG4gKiB0aGUgY2F1c2UuXG4gKi9cbldFcnJvci5wcm90b3R5cGUuY2F1c2UgPSBmdW5jdGlvbiB3ZV9jYXVzZShjKVxue1xuXHRpZiAobW9kX2lzRXJyb3IoYykpXG5cdFx0dGhpcy5qc2VfY2F1c2UgPSBjO1xuXG5cdHJldHVybiAodGhpcy5qc2VfY2F1c2UpO1xufTtcbiJdLCJuYW1lcyI6WyJtb2RfYXNzZXJ0cGx1cyIsInJlcXVpcmUiLCJtb2RfdXRpbCIsIm1vZF9leHRzcHJpbnRmIiwibW9kX2lzRXJyb3IiLCJpc0Vycm9yIiwic3ByaW50ZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJWRXJyb3IiLCJTRXJyb3IiLCJXRXJyb3IiLCJNdWx0aUVycm9yIiwicGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyIsImFyZ3MiLCJhcmd2Iiwib3B0aW9ucyIsInNwcmludGZfYXJncyIsInNob3J0bWVzc2FnZSIsImsiLCJvYmplY3QiLCJib29sIiwic3RyaWN0IiwiYXJyYXkiLCJsZW5ndGgiLCJzbGljZSIsInN0cmluZyIsIm1hcCIsImEiLCJ1bmRlZmluZWQiLCJhcHBseSIsIm9iaiIsInBhcnNlZCIsImNhdXNlIiwiY3RvciIsIm1lc3NhZ2UiLCJBcnJheSIsInByb3RvdHlwZSIsImNhbGwiLCJhcmd1bWVudHMiLCJPYmplY3QiLCJjcmVhdGUiLCJuYW1lIiwianNlX3Nob3J0bXNnIiwib2siLCJqc2VfY2F1c2UiLCJza2lwQ2F1c2VNZXNzYWdlIiwianNlX2luZm8iLCJpbmZvIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImNvbnN0cnVjdG9yT3B0IiwiY29uc3RydWN0b3IiLCJpbmhlcml0cyIsInRvU3RyaW5nIiwidmVfdG9TdHJpbmciLCJzdHIiLCJoYXNPd25Qcm9wZXJ0eSIsInZlX2NhdXNlIiwiZXJyIiwicnYiLCJmaW5kQ2F1c2VCeU5hbWUiLCJoYXNDYXVzZVdpdGhOYW1lIiwiZnVsbFN0YWNrIiwic3RhY2siLCJlcnJvckZyb21MaXN0IiwiZXJyb3JzIiwiYXJyYXlPZk9iamVjdCIsImZvckVhY2giLCJlIiwiZXJyb3JGb3JFYWNoIiwiZnVuYyIsIml0ZXJFcnJvciIsImFzZV9lcnJvcnMiLCJtZV9lcnJvcnMiLCJ3ZV90b1N0cmluZyIsIndlX2NhdXNlIiwiYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/verror/lib/verror.js\n");

/***/ })

};
;